<?php
require_once __DIR__ . "/../../../../include/dbcommon.php";

use Base\{ArrayUtils, DateTimeUtils, Utils as BaseUtils, Validations, GraphicUtils as BaseGraphicUtils};
use Base\QueryBuilder\Select;
use BBPlanner\Constants\{Permissions, ReservationGuestsStatus, ReservationOrigins, ReservationPaymentStatues, ReservationStatus};
use BBPlanner\Entities\{Closure, ClosuresServices, PaymentMethodsServices, Reservation, ReservationsServices, ReservationUnit, ReservationUnitsServices, StructuresServices, TypologiesServices, Typology, Unit, UnitsServices};
use Spatie\HtmlElement\HtmlElement;

$response = BaseUtils::executeCatchedScript(function () {
    Validations::validate($_POST, [
        "structureID" => Validations::IS_POSITIVE_INTEGER,
        "start" => Validations::IS_DATE_STRING,
        "end" => Validations::IS_DATE_STRING,
    ]);

    $structure = StructuresServices::get($_POST["structureID"]);

    $units = UnitsServices::getSome(function (Select $query) use ($structure) {
        $query->isEqual("structureID", $structure->id);
        $query->isEqual("isActive", true);
        $query->addOrderBy("order");
        $query->addOrderBy("id");
    });

    $units = array_map(function (Unit $unit) use ($structure) {
        return (object) [
            "typologyID" => $unit->typologyID,
            "id" => $unit->id,
            "code" => $unit->code,
            "nameTexts" => $unit->getNameTexts(),
            "isConnectedToChannel" => $structure->useTypologies ? false : $unit->isConnectedToTheChannel(),
        ];
    }, $units);

    if ($structure->useTypologies && $structure->checkPermission(Permissions::BOOKING)) {
        $typologies = TypologiesServices::getSome(function (Select $query) use ($structure) {
            $query->isEqual("structureID", $structure->id);
            $query->addOrderBy("order");
        });

        $typologies = array_map(function (Typology $typology) {
            return (object) [
                "id" => $typology->id,
                "nameTexts" => $typology->getNameTexts(),
                "isConnectedToChannel" => $typology->isConnectedToChannel(),
            ];
        }, $typologies);
    }

    $reservationsUnits = ReservationUnitsServices::getSome(function (Select $query) use ($structure) {
        $query->isEqual("structureID", $structure->id);
        $query->isSmallerOrEqualThan("checkIn", $_POST["end"]);
        $query->isGreaterOrEqualThan("checkOut", $_POST["start"]);
        $query->isNotEqual("statusID", ReservationStatus::CANCELED);
        $query->isEqual("isCanceled", false);
    });

    if (Validations::isNotEmpty($reservationsUnits)) {
        $reservations = ReservationsServices::getSome(function (Select $query) use ($reservationsUnits) {
            $query->isAnyOf("id", array_unique(array_map(function (ReservationUnit $reservationUnit) {
                return $reservationUnit->getReservationID();
            }, $reservationsUnits)));
        });
    } else {
        $reservations = [];
    }

    $closures = ClosuresServices::getSome(function (Select $query) use ($structure) {
        $query->isEqual("structureID", $structure->id);
        $query->isSmallerOrEqualThan("start", $_POST["end"]);
        $query->isGreaterOrEqualThan("end", $_POST["start"]);
    });

    list($closures, $fakeClosures) = array_values((array) array_reduce($closures, function (stdClass $data, Closure $closure) {
        if (Validations::isNotEmpty($closure->masterReservationUnitID)) {
            $data->fakeClosures[] = $closure;
        } else {
            $data->closures[] = $closure;
        }

        return $data;
    }, (object) [
        "closures" => [],
        "fakeClosures" => [],
    ]));

    $unitGroupedFakeClosures = array_reduce($fakeClosures, function (array $unitGroupedFakeClosures, Closure $fakeClosure) {
        $unitGroupedFakeClosures[$fakeClosure->unitID][] = $fakeClosure;
        return $unitGroupedFakeClosures;
    }, []);

    $fakeClosures = ArrayUtils::flat(array_map(function (array $fakeClosuresUnit, string $unitID) {
        $closedDates = array_unique(ArrayUtils::flat(array_map(function (Closure $fakeClosure) {
            return array_map(["Base\DateTimeUtils", "getISODate"], DateTimeUtils::getAllDatesInARange($fakeClosure->start, $fakeClosure->end));
        }, $fakeClosuresUnit)));

        $minDate = min(min($closedDates), $_POST["start"]);
        $maxDate = max(max($closedDates), $_POST["end"]);
        $allDates = array_map(["Base\DateTimeUtils", "getISODate"], DateTimeUtils::getAllDatesInARange($minDate, $maxDate));

        list($closedRanges) = array_values((array) array_reduce($allDates, function (stdClass $data, string $date) use ($fakeClosuresUnit, $unitID) {
            $closuresInDate = ArrayUtils::filter($fakeClosuresUnit, function (Closure $closure) use ($date) {
                return $closure->start <= $date && $date <= $closure->end;
            });

            if (Validations::isNotEmpty($closuresInDate)) {
                if ($data->reset) {
                    //INITIAL
                    $data->closedRanges[] = (object) [
                        "id" => "FC_{$unitID}_{$date}",
                        "unitID" => $unitID,
                        "start" => $date,
                        "end" => $date,
                    ];
                    $data->reset = false;
                } else {
                    $lastIndex = count($data->closedRanges) - 1;
                    $data->closedRanges[$lastIndex]->end = $date;

                    $closuresInDateWithFutureCheckOutPresence = ArrayUtils::count($closuresInDate, function (Closure $closure) use ($date) {
                        return $date < $closure->end;
                    }) > 0;

                    $data->reset = !$closuresInDateWithFutureCheckOutPresence;
                }
            }

            return $data;
        }, (object) [
            "closedRanges" => [],
            "reset" => true
        ]));

        return $closedRanges;
    }, $unitGroupedFakeClosures, array_keys($unitGroupedFakeClosures)));

    $paymentMethods = PaymentMethodsServices::getSome(function (Select $query) use ($structure) {
        $query->isEqual("structureID", $structure->id);
    });

    // ELABORATION
    $events = array_map(function (ReservationUnit $reservationUnit) use ($reservations, $paymentMethods) {
        $reservation = ArrayUtils::find($reservations, function (Reservation $reservation)  use ($reservationUnit) {
            return $reservation->id === $reservationUnit->getReservationID();
        });

        // $total = $reservation->getTotalAmount();
        // $balance = $reservation->getBalanceAmount();

        if ($reservation->statusID === ReservationStatus::OPTIONED) {
            $class = "optioned";
        } else if (/*$balance === $total*/$reservation->paymentStatusID === ReservationPaymentStatues::NO_AMOUNT_RECEIVED) {
            $class = "no_amount_paid";
        } else if (/*$balance > 0*/$reservation->paymentStatusID === ReservationPaymentStatues::PARTIAL_WELDED) {
            $class = "partial_welded";
        } else if ($reservation->paymentStatusID === ReservationPaymentStatues::WELDED) {
            $class = "total_welded";
        }

        // if ($reservationUnit->checkOut < date("Y-m-d")) {
        //     $class .= "_past";
        // }

        $channel = $reservationUnit->getChannel();

        $movements = $reservation->getMovements();
        $paymentMethodsIDs = array_column($movements, "paymentMethodID");
        $paymentMethodsIDs[] = $reservation->paymentMethodID;
        $paymentMethodsIDs = array_unique(ArrayUtils::filter($paymentMethodsIDs, ["Base\Validations", "isNotEmpty"]));

        // if (Validations::isNotEmpty($paymentMethodsIDs)) {
        //     dump_dati($paymentMethodsIDs, print_r, false);
        //     dump_dati($paymentMethods, print_r, false);
        // }

        $paymentMethodsLabels = array_map(function (string $paymentMethodID) use ($paymentMethods) {
            $index = array_search($paymentMethodID, array_column($paymentMethods, "id"));
            return $paymentMethods[$index]->label;
        }, $paymentMethodsIDs);

        return (object) [
            "eventType" => "reservation",
            "reservationID" => $reservation->id,
            "id" => $reservationUnit->id,
            "start_date" => "$reservationUnit->checkIn 09:00:00",
            "end_date" => "$reservationUnit->checkOut 08:00:00",
            "section_id" => $reservationUnit->unitID ?: "{$reservationUnit->typologyID}_NU",

            "adults" => $reservationUnit->adults,
            "children" => $reservationUnit->children,
            "surname" => $reservation->surname,
            "name" => $reservation->name,
            "nominativeRoom" => $reservationUnit->nominativeRoom,
            "stayPrice" => $reservationUnit->stayPrice,
            "stayPriceIsBlocked" => $reservationUnit->stayPriceIsBlocked(),
            "totalPrice" => $reservationUnit->getTotalPrice(),
            // "checkIn" => $reservationUnit->checkIn,
            // "checkOut" => $reservationUnit->checkOut,
            "channelIcon" => Validations::isEmpty($channel) ? null : $channel->getLabel(true),
            "guestsStatusID" => $reservationUnit->guestsStatusID,
            "isMultiUnitReservation" => $reservationUnit->isMain() ? $reservation->haveMoreThanOneReservationUnits() : true,
            "creationDatetime" => $reservationUnit->creationDateTime,
            "note" => $reservation->note,
            "reservationID" => $reservation->id,
            "locked" => $reservationUnit->originID === ReservationOrigins::WUBOOK && !$reservationUnit->unlocked,
            "class" => $class,
            "paymentMethodsLabels" => $paymentMethodsLabels,
        ];
    }, $reservationsUnits);

    $events = array_reduce($closures, function (array $events, Closure $closure) {
        $events[] = (object) [
            "eventType" => "closure",
            "id" => $closure->id,
            "start_date" => "$closure->start 09:00:00",
            "end_date" => "$closure->end 08:00:00",
            "section_id" => $closure->unitID,
            "class" => "closure",
            "creationDatetime" => $closure->creationDateTime,
        ];

        return $events;
    }, $events);

    $events = array_reduce($fakeClosures, function (array $events, stdClass $fakeClosure) {
        $events[] = (object) [
            "eventType" => "fakeClosure",
            "id" => $fakeClosure->id,
            "start_date" => "$fakeClosure->start 09:00:00",
            "end_date" => "$fakeClosure->end 08:00:00",
            "section_id" => $fakeClosure->unitID,
            "class" => "closure",
        ];

        return $events;
    }, $events);

    return [
        "events" => $events,
        "typologies" => $typologies,
        "units" => $units,
    ];
}, false);
