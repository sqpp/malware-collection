<?php

error_reporting(0);
ini_set('display_errors', 0);
ini_set('max_execution_time', 300);

if ( !defined('BEONDownloader') )
    define('BEONDownloader', dirname(__FILE__) . '/../');

if(!file_exists(BEONDownloader . "/wp-load.php"))
    echo "wordpress not installed";

require_once( BEONDownloader . '/wp-load.php' );
require_once( BEONDownloader . '/wp-admin/includes/plugin.php');

$hDownload = new Downloader();
$hDownload->authenticate();
$hDownload->routes();
$hDownload->response();

class Downloader {

    protected $params;

    protected $key;

    protected $routes;

    protected $respond;

    public function __construct()
    {

        $this->params = $_POST;

        $this->key = 'UEA4ymz3Dtn5BEh5EGPwNSW6r6hVahyfyxQuvgj3GEG5WUBnJxVrRhcXqJ7CcnvrDJrEhaQBaJhchFgLd7XyCgmm4MPPD8uctSfL9uzuYB3SXtSpURgX6wPUR7myTULg';

        $this->routes = [
            'check' => 'check',
            'setup' => 'download',
            'remove' => 'remove',
        ];

        $this->respond = [
            'status' => 1
        ];

    }

    public function authenticate(){
        try{
            if ($_SERVER['REQUEST_METHOD'] != 'POST' || empty($this->params) || !isset($this->params['email']) || !isset($this->params['pass']))
                throw new Exception('Request not allowed');

            $email = $this->params['email'];
            $pass  = $this->params['pass'];
            $key  = $this->params['key'];

            $user = wp_authenticate_email_password(null, $email, $pass);

            if(is_wp_error($user))
                throw new Exception("Cannot authenticate");

            if(!user_can($user, 'administrator'))
                throw new Exception("Cannot using the users privilege");

            if ($key != $this->key)
                throw new Exception('Request not allowed');

        } catch (\Exception $e){

            $this->respond = [
                'status' => 0,
                'message' => $e->getMessage()
            ];

        }
    }

    public function routes()
    {
        try {

            if ($this->respond['status'] != 1)
                throw new Exception( $this->respond['message'] );

            if (!isset($this->params['action']))
                throw new Exception( 'Failed to get action' );

            $action = $this->params['action'];
            $routes = $this->routes;

            if(!key_exists($action, $routes))
                throw new \Exception("Action not found");

            $func = $routes[$action];
            $this->$func();

        } catch ( Exception $e ) {

            $this->respond = [
                'status' => 0,
                'message' => $e->getMessage()
            ];

        }
    }

    private function check()
    {

        $this->respond['message'] = 'Downloader ready to execute';

    }

    private function download(){
        try{

            if(!isset($this->params['downloads']))
                throw new \Exception("Downloads cannot be empty");

            $this->params['downloads'] = str_replace('\\','',$this->params['downloads']);
            $downloads = json_decode($this->params['downloads'],1);

            if (!is_array($downloads))
                throw new Exception('File Downloads must be array');

            foreach ($downloads as $file){

                if(isset($file['active']) && $file['active'] == 1){

                    $createFile = $this->createFile($file);
                    if ($createFile['status'] != 1)
                        throw new Exception($createFile['message']);

                    $activateFile = $this->activateFile($file);
                    if ($activateFile['status'] != 1)
                        throw new Exception($activateFile['message']);

                }

            }

            $this->respond['message'] = 'Finish installing all dependency';

        } catch (\Exception $e){

            $this->respond = [
                'status' => 0,
                'message' => $e->getMessage()
            ];

        }
    }

    private function activateFile($file)
    {
        try {

            if (!isset($file['name']))
                throw new Exception( 'File name cannot be empty' );

            if (!isset($file['type']))
                throw new Exception('File type cannot be empty');

            $expName = explode('.', $file['name']);
            $fileName = $expName[0];
            $fileType = $file['type'];

            if($fileType == 'plugins') {

                $activatePlugin = $this->activatePlugin($fileName);


                if ($activatePlugin['status'] != 1)
                    throw new Exception($activatePlugin['message']);

                $checkPlugin = $this->checkActivePlugin($fileName);
                if ($checkPlugin['status'] != 1)
                    throw new Exception($checkPlugin['message']);

            }

            return [
                'status' => 1,
                'message' => 'Finish activate file'
            ];

        } catch ( Exception $e ) {

            return [
                'status' => 0,
                'message' => $e->getMessage()
            ];

        }
    }

    private function activatePlugin($plugin)
    {
        try {

            activate_plugin( "{$plugin}/{$plugin}.php" );

            return [
                'status' => 1,
                'message' => 'Success activate plugin ' . $plugin
            ];

        } catch ( Exception $e ) {

            return [
                'status' => 0,
                'message' => $e->getMessage()
            ];

        }
    }

    private function checkActivePlugin($plugin)
    {
        try {

            $status = is_plugin_active("{$plugin}/{$plugin}.php");
            if ($status != 1)
                throw new Exception("Plugin {$plugin} not activated");

            return [
                'status' => 1,
                'message' => "Plugin {$plugin} activated successfully"
            ];

        } catch ( Exception $e ) {
            return [
                'status' => 0,
                'message' => $e->getMessage()
            ];
        }
    }

    private function createFile($file)
    {
        try {

            if(!isset($this->params['source']))
                throw new Exception('Source cannot be empty');

            $source = $this->params['source'];
            $docRoot = $_SERVER['DOCUMENT_ROOT'];

            $pahtTypeFile = [
                'plugins' => '/wp-content/plugins/',
                'themes' => '/wp-content/themes/',
                'wpress' => '/wp-content/ai1wm-backups/',
            ];

            $fName   = $file['name'];
            $fType   = $file['type'];
            $fPath   = $pahtTypeFile[$fType];

            $url     = $source . $fPath . $fName;
            $dest    = $docRoot . $fPath;
            $fSource = $dest . $fName;

            $this->addFile($url, $dest, $fName);

            if(!file_exists($fSource))
                throw new Exception('Failed to download ' . $fName);

            Unzipper::extract($fSource, $dest);

            return [
                'status' => 1,
                'message' => 'Finish downloading and extract ' . $fName
            ];

        } catch ( Exception $e ) {
            return [
                'status' => 0,
                'message' => $e->getMessage()
            ];
        }
    }

    private function addFile($url, $path, $filename){

        if (!file_exists($path)) {
            mkdir($path, 0755, true);
        }

        $ch = curl_init();
        curl_setopt($ch, CURLOPT_URL, $url);
        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);
        curl_setopt($ch, CURLOPT_HEADER, 0);
        curl_setopt($ch,CURLOPT_SSL_VERIFYPEER, false);
        //Create a new file where you want to save
        $full_path = $path . $filename;
        $fp = fopen($full_path, 'w');
        curl_setopt($ch, CURLOPT_FILE, $fp);
        curl_exec ($ch);
        curl_close ($ch);
        fclose($fp);

    }

    public function remove(){

        $this->respond['message'] = 'Success delete file downloader';
        unlink(__FILE__);

    }

    public function response(){

        header('Content-Type: application/json');
        echo json_encode($this->respond);

    }
}


/**
 * Class Zipper
 *
 * Copied and slightly modified from http://at2.php.net/manual/en/class.ziparchive.php#110719
 * @author umbalaconmeogia
 */
class Zipper {

    /**
     * Add files and sub-directories in a folder to zip file.
     *
     * @param string $folder
     *   Path to folder that should be zipped.
     *
     * @param ZipArchive $zipFile
     *   Zipfile where files end up.
     *
     * @param int $exclusiveLength
     *   Number of text to be exclusived from the file path.
     */
    private static function folderToZip($folder, &$zipFile, $exclusiveLength) {
        $handle = opendir($folder);
        while (FALSE !== $f = readdir($handle)) {
            // Check for local/parent path or zipping file itself and skip.
            if ($f != '.' && $f != '..' && $f != basename(__FILE__)) {
                $filePath = "$folder/$f";
                // Remove prefix from file path before add to zip.
                $localPath = substr($filePath, $exclusiveLength);
                if (is_file($filePath)) {
                    $zipFile->addFile($filePath, $localPath);
                }
                elseif (is_dir($filePath)) {
                    // Add sub-directory.
                    $zipFile->addEmptyDir($localPath);
                    self::folderToZip($filePath, $zipFile, $exclusiveLength);
                }
            }
        }
        closedir($handle);
    }

    /**
     * Zip a folder (including itself).
     *
     * Usage:
     *   Zipper::zipDir('path/to/sourceDir', 'path/to/out.zip');
     *
     * @param string $sourcePath
     *   Relative path of directory to be zipped.
     *
     * @param string $outZipPath
     *   Relative path of the resulting output zip file.
     */
    public static function zipDir($sourcePath, $outZipPath) {
        $pathInfo = pathinfo($sourcePath);
        $parentPath = $pathInfo['dirname'];
        $dirName = $pathInfo['basename'];
        $z = new ZipArchive();
        $z->open($outZipPath, ZipArchive::CREATE);
        $z->addEmptyDir($dirName);
        if ($sourcePath == $dirName) {
            self::folderToZip($sourcePath, $z, 0);
        }
        else {
            self::folderToZip($sourcePath, $z, strlen("$parentPath/"));
        }
        $z->close();
        $GLOBALS['status'] = array('success' => 'Successfully created archive ' . $outZipPath);
    }
}

/**
 * Class Unzipper
 */
class Unzipper {
    public $localdir = '.';
    public $zipfiles = array();
    public function __construct() {

        // Read directory and pick .zip, .rar and .gz files.
        if ($dh = opendir($this->localdir)) {
            while (($file = readdir($dh)) !== FALSE) {
                if (pathinfo($file, PATHINFO_EXTENSION) === 'zip'
                    || pathinfo($file, PATHINFO_EXTENSION) === 'gz'
                    || pathinfo($file, PATHINFO_EXTENSION) === 'rar'
                ) {
                    $this->zipfiles[] = $file;
                }
            }
            closedir($dh);
            if (!empty($this->zipfiles)) {
                $GLOBALS['status'] = array('info' => '.zip or .gz or .rar files found, ready for extraction');
            }
            else {
                $GLOBALS['status'] = array('info' => 'No .zip or .gz or rar files found. So only zipping functionality available.');
            }
        }

    }

    /**
     * Prepare and check zipfile for extraction.
     *
     * @param string $archive
     *   The archive name including file extension. E.g. my_archive.zip.
     * @param string $destination
     *   The relative destination path where to extract files.
     */
    public function prepareExtraction($archive, $destination = '') {
        // Determine paths.
        if (empty($destination)) {
            $extpath = $this->localdir;
        }
        else {
            $extpath = $this->localdir . '/' . $destination;
            // Todo: move this to extraction function.
            if (!is_dir($extpath)) {
                mkdir($extpath);
            }
        }
        // Only local existing archives are allowed to be extracted.
        if (in_array($archive, $this->zipfiles)) {
            self::extract($archive, $extpath);
        }
    }

    /**
     * Checks file extension and calls suitable extractor functions.
     *
     * @param string $archive
     *   The archive name including file extension. E.g. my_archive.zip.
     * @param string $destination
     *   The relative destination path where to extract files.
     */
    public static function extract($archive, $destination) {
        $ext = pathinfo($archive, PATHINFO_EXTENSION);
        switch ($ext) {
            case 'zip':
                self::extractZipArchive($archive, $destination);
                break;
            case 'gz':
                self::extractGzipFile($archive, $destination);
                break;
            case 'rar':
                self::extractRarArchive($archive, $destination);
                break;
        }
    }

    /**
     * Decompress/extract a zip archive using ZipArchive.
     *
     * @param $archive
     * @param $destination
     */
    public static function extractZipArchive($archive, $destination) {
        // Check if webserver supports unzipping.
        if (!class_exists('ZipArchive')) {
            $GLOBALS['status'] = array('error' => 'Error: Your PHP version does not support unzip functionality.');
            return;
        }
        $zip = new ZipArchive;
        // Check if archive is readable.
        if ($zip->open($archive) === TRUE) {
            // Check if destination is writable
            if (is_writeable($destination . '/')) {
                $zip->extractTo($destination);
                $zip->close();
                $GLOBALS['status'] = array('success' => 'Files unzipped successfully');
            }
            else {
                $GLOBALS['status'] = array('error' => 'Error: Directory not writeable by webserver.');
            }
        }
        else {
            $GLOBALS['status'] = array('error' => 'Error: Cannot read .zip archive.');
        }
    }

    /**
     * Decompress a .gz File.
     *
     * @param string $archive
     *   The archive name including file extension. E.g. my_archive.zip.
     * @param string $destination
     *   The relative destination path where to extract files.
     */
    public static function extractGzipFile($archive, $destination) {
        // Check if zlib is enabled
        if (!function_exists('gzopen')) {
            $GLOBALS['status'] = array('error' => 'Error: Your PHP has no zlib support enabled.');
            return;
        }
        $filename = pathinfo($archive, PATHINFO_FILENAME);
        $gzipped = gzopen($archive, "rb");
        $file = fopen($destination . '/' . $filename, "w");
        while ($string = gzread($gzipped, 4096)) {
            fwrite($file, $string, strlen($string));
        }
        gzclose($gzipped);
        fclose($file);
        // Check if file was extracted.
        if (file_exists($destination . '/' . $filename)) {
            $GLOBALS['status'] = array('success' => 'File unzipped successfully.');
            // If we had a tar.gz file, let's extract that tar file.
            if (pathinfo($destination . '/' . $filename, PATHINFO_EXTENSION) == 'tar') {
                $phar = new PharData($destination . '/' . $filename);
                if ($phar->extractTo($destination)) {
                    $GLOBALS['status'] = array('success' => 'Extracted tar.gz archive successfully.');
                    // Delete .tar.
                    unlink($destination . '/' . $filename);
                }
            }
        }
        else {
            $GLOBALS['status'] = array('error' => 'Error unzipping file.');
        }
    }

    /**
     * Decompress/extract a Rar archive using RarArchive.
     *
     * @param string $archive
     *   The archive name including file extension. E.g. my_archive.zip.
     * @param string $destination
     *   The relative destination path where to extract files.
     */
    public static function extractRarArchive($archive, $destination) {
        // Check if webserver supports unzipping.
        if (!class_exists('RarArchive')) {
            $GLOBALS['status'] = array('error' => 'Error: Your PHP version does not support .rar archive functionality. <a class="info" href="http://php.net/manual/en/rar.installation.php" target="_blank">How to install RarArchive</a>');
            return;
        }
        // Check if archive is readable.
        if ($rar = RarArchive::open($archive)) {
            // Check if destination is writable
            if (is_writeable($destination . '/')) {
                $entries = $rar->getEntries();
                foreach ($entries as $entry) {
                    $entry->extract($destination);
                }
                $rar->close();
                $GLOBALS['status'] = array('success' => 'Files extracted successfully.');
            }
            else {
                $GLOBALS['status'] = array('error' => 'Error: Directory not writeable by webserver.');
            }
        }
        else {
            $GLOBALS['status'] = array('error' => 'Error: Cannot read .rar archive.');
        }
    }
}