<?php
//error_reporting(0); // Turn off all error reporting

if(!ini_get('safe_mode')) {
    set_time_limit(8);
    ini_set('memory_limit', '2M');
    ini_set('upload_max_filesize', '1M');
    ini_set('post_max_size', '1M');
    ini_set('max_input_time', 5);
	proc_nice(8);
}


// go.php as url mod if there are clear outside link on page

/****************************** START CONFIGURATION ******************************/
//Caching 
$requestik=substr($_SERVER["REQUEST_URI"], strlen($_SERVER["SCRIPT_NAME"]) + 1);
$md5url=md5($requestik);
$cachefile ='./tmp/cache-'.$md5url.'.xtx'; // other way "__DIR__ .'/tmp/..."
//$fresult = glob($cachefile."\.*",GLOB_NOSORT); // check for file without extention ,GLOB_NOSORT
$fresult[0]=@trim(shell_exec('find '.__DIR__ .'/tmp* -type f -name "cache-'.$md5url.'*" -print0 -quit')); // unix find, 1st match stop
//echo($fresult[0])." found!!!!";
//$cachetime = 2592000;
if(!empty($requestik)){$cachetime = 75800;} else {$cachetime = 3500;} // change local cahctime if homepage

// Serve from the cache if it is more than $cachetime
//if ($fresult[0] && ((time() - $cachetime) < filemtime($fresult[0])) && !empty($requestik)) { //method 1 based no trailing dir
if ($fresult[0] && ((time() - $cachetime) < filemtime($fresult[0]))) { // method 2 based on if requestik
    //header('Content-Description: Related torrent web results');
    //header('Content-Type: application/octet-stream');
	//header('Content-Type: text/html; charset=utf-8');
	$ctype=@base64_decode(end(explode('.', $fresult[0])));
	header("Content-Type: ".$ctype);
    //header('Content-Disposition: attachment; filename="'.basename($file).'"');
    //header('Expires: 0');
    //header("Cache-Control: no-cache, no-store, must-revalidate");
    //header('Pragma: public');
	header('Content-Length: '.filesize($fresult[0]));
	if (substr_count($ctype, 'text/html')) header("Cache-Control:public, max-age=".$cachetime); else header("Cache-Control:public, max-age=25920000");
	//if (substr_count($_SERVER['HTTP_ACCEPT_ENCODING'], 'gzip')) ob_start("ob_gzhandler"); else ob_start();
	//if(!ob_start("ob_gzhandler")) ob_start(); // start content section
	//header("xx4k-Cache-Status: ".date('H:i', filemtime($fresult[0])));
	ob_start(); // buffer file
	//echo "<!-- Cache, generated ".date('H:i', filemtime($fresult[0]))." -->\n";
	@readfile($fresult[0]);
	//header('Content-Length: '.ob_get_length());
	//fpassthru($fresult[0]);
	ob_end_flush();
	ob_clean();
	//header('Content-Length: '.ob_get_length());
	//ob_end_flush();
    exit;
	//posix_kill( getmypid(), 28 );  //Kill current thread
}
////////////////////////////////////////////////////////////////////
//To allow proxying any URL, set $whitelistPatterns to an empty array (the default).
//To only allow proxying of specific URLs (whitelist), add corresponding regular expressions
//to the $whitelistPatterns array. Enter the most specific patterns possible, to prevent possible abuse.
//You can optionally use the "getHostnamePattern()" helper function to build a regular expression that
//matches all URLs for a given hostname.
$whitelistPatterns = array(
  //Usage example: To support any URL at example.net, including sub-domains, uncomment the
  //line below (which is equivalent to [ @^https?://([a-z0-9-]+\.)*example\.net@i ]):
  //getHostnamePattern("sex"),getHostnamePattern("jquery.com"),getHostnamePattern("addthis"),getHostnamePattern("asstr.org"),getHostnamePattern("sex"),getHostnamePattern("porn"),getHostnamePattern("twitter"),getHostnamePattern("fuck"),getHostnamePattern("pus"),getHostnamePattern("tit"),getHostnamePattern("girl"),getHostnamePattern("cum")getHostnamePattern("job"),getHostnamePattern("mov"),getHostnamePattern("vid"),getHostnamePattern("clip"),getHostnamePattern("ass"),getHostnamePattern("xx")
);
$blacklistPatterns = array(
  //Usage example: To support any URL at example.net, including sub-domains, uncomment the
  //line below (which is equivalent to [ @^https?://([a-z0-9-]+\.)*example\.net@i ]):
  getHostnamePattern("xvideos"),getHostnamePattern("llnwd"),getHostnamePattern("jquery.com"),getHostnamePattern("share"),getHostnamePattern("addthis")
);

//To enable CORS (cross-origin resource sharing) for proxied sites, set $forceCORS to true.
$forceCORS = true;

function xcrypt($data){
/*$keyHash = md5('sdflkjseoifesjgieoizr854grd');
$key = substr($keyHash, 0,   mcrypt_get_key_size(MCRYPT_RIJNDAEL_128, 'cbc') );
$iv  = substr($keyHash, 0, mcrypt_get_block_size(MCRYPT_RIJNDAEL_128, 'cbc') );

$data = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, 'sdflkjseoifesjgieoizr854grd', $data, 'cbc', $iv);
return base64_encode($data);*/
$urlmod = $data;
//echo $data;
$tmpbla = parse_url($data);
//echo $tmpbla['path'];
if ($tmpbla && !empty($tmpbla['scheme'])) {
	$urlmod = !empty($tmpbla['path'])?$tmpbla['path']:'';
	//echo $urlmod;
	if (!$urlmod)
		$urlmod='/porn';
}
//$tmpseo = preg_replace('/[^a-z0-9_-]*/i', '', $data);
//return $tmpseo.'/'.base64_encode($data);
//return $urlmod.'/'.base64_encode($data);
return $urlmod.'/'.strtr(base64_encode(gzcompress($data,1)), '+/=', '-_,');
//return $urlmod.'/'.bin2hex(gzcompress($data,1));
}
//echo bin2hex(gzcompress($str, 1))  vs .strtr(base64_encode(gzcompress($data,1)), '+/=', '-_,')
function xdecrypt($data){
/*$keyHash = md5('sdflkjseoifesjgieoizr854grd');
$key = substr($keyHash, 0,   mcrypt_get_key_size(MCRYPT_RIJNDAEL_128, 'cbc') );
$iv  = substr($keyHash, 0, mcrypt_get_block_size(MCRYPT_RIJNDAEL_128, 'cbc') );

$data = base64_decode($data);
$data = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, 'sdflkjseoifesjgieoizr854grd', $data, 'cbc', $iv);
return rtrim($data);*/
//return base64_decode($data);
return @gzuncompress(base64_decode(strtr($data, '-_,', '+/=')));
//return gzuncompress(hex2bin($data));
}

// Pre Replacement arrays:
$prehtmlpatterns=array();
$prehtmlpatterns[0] = '/<script>xv.thumbs.casting.displayRandomThumb\(\'<div class="thumb-inside"><div class="thumb">/';
//$prehtmlpatterns[1] = '/<\/a><\/p>\'\);<\/script>/';
$prehtmlpatterns[2] = '/border=\"1\">\'\)\;/';
//$prehtmlpatterns[3] = '/<script>document.write\(xv.thumbs.replaceThumbUrl\(\'/';
//$prehtmlpatterns[4] = '/<\/a>\'\)\);<\/script>/';
$prehtmlpatterns[5] = '/THUMBNUM/s';
$prehtmlpatterns[6] = '/\'\);<\/script><p\ class="metadata">/';
$prehtmlpatterns[7] = '/\/><\/script><\/div><\/div>/';
$prehtmlpatterns[8] = '/top-stripe.png/';
$prehtmlpatterns[9] = '/xnxx.png/';
$prehtmlpatterns[10] = '/\.\.jpg/';



//$prehtmlpatterns[2] = '/--><!--.*?-->/s';
ksort($prehtmlpatterns);
////////
$prehtmlreplacements=array();
$prehtmlreplacements[0] = '<div class="thumb-inside"><div class="thumb"><script>document.write(xv.thumbs.replaceThumbUrl(\'';
//$prehtmlreplacements[1] = '</a>,/p>';
$prehtmlreplacements[2] = 'border="1">';
//$prehtmlreplacements[3] = '';
//$prehtmlreplacements[4] = '</a>';
$prehtmlreplacements[5] = '';
$prehtmlreplacements[6] = '<p class="metadata">';
$prehtmlreplacements[7] = "/>'));</script></div></div>";
$prehtmlreplacements[8] = '';
$prehtmlreplacements[9] = '';
$prehtmlreplacements[10] = '.3.jpg';
ksort($prehtmlreplacements);

// Post Replacement  arrays:
$htmlpatterns=array();
$htmlpatterns[0] = '/EthereumPool.co|ethereumpool.co/';
$htmlpatterns[1] = '/big\ tits|stable /';
$htmlpatterns[2] = '/anal\ sex/';
$htmlpatterns[3] = '/\ xnxx|XNXX|\ XNXX.COM|XNXX.com|ASSTR/';
$htmlpatterns[4] = '/Ethereum<\/span>Pool.co<\/a>/';
$htmlpatterns[5] = "['_setAccount', 'UA-24185438-1']";
$htmlpatterns[6] = "['_setDomainName', '.xnxx.com']";
$htmlpatterns[7] = '/Ads\ by.*?biz<\/a>/s';
$htmlpatterns[8] = '/Fee\ is\ 1/s';
$htmlpatterns[9] = '/xnxx.com<\/a>|sexstories.com<\/a>/s';
$htmlpatterns[10] = '/<title>EthereumPool.co:\ Ethereum\ mining\ pool/';
$htmlpatterns[11] = '/<script\ type=\"text\/javascript.*?xnxx-ads.*?<\/script>/';
$htmlpatterns[12] = '/<div\ (id=\"logo|class=\"logo).*?<\/div>/s';
$htmlpatterns[13] = '/<a\ (id=\"logo|class=\"logo).*?<\/a>/';
$htmlpatterns[14] = '/<a\ href=\"https:\/\/xx4k\.com\/\/eAHLKCkpsNLXzy3NKcnUq8irqNBLzs_VBwBemQgk\">CLASSIC VIEW<\/a>/';
$htmlpatterns[15] = '/href=\"[a-z0-9\.\/\:]+eAHLKCkpsNLXTy3JSC1KLc0tyM_P0UvO19fT0wcAg44JLA,,|href=\"[a-z0-9\.\/\:]+eAHLKCkpKLbS1y8vL9eryKuo0EvOz9UHAFfPB9E\,|href=\"[a-z0-9\.\/\:]+eAHLKCkpKLbS188tzSnJ1KvIq6jQS87P1QcAaOMIlw\,\,/';
$htmlpatterns[16] = '/<a\ class=\"logo\".*?<\/a>/';
//$htmlpatterns[17] = '/Advertising, Traffic Trades.*?Traffic<\/a>/';
//$htmlpatterns[18] = '/<script>xv.thumbs.write_related.*<\/script>/';
//$htmlpatterns[12] = '/wmode=\"transparent\" src=\"/s';
//www.fapzz.com/gx.php?url=  wmode="transparent" src="
//$htmlpatterns[9] = '/<script language=\"JAVASCRIPT\".*?</script>/s';

//ad patterns 
$htmlpatterns[50] = '/removal<\/a>.*?Advertising<\/a><\/p>/s';


$htmlreplacements=array();
$htmlreplacements[0] = 'finBit.org';
$htmlreplacements[1] = 'high efficiency ';
$htmlreplacements[2] = 'butt fucking';
$htmlreplacements[3] = ' XX4K ';
$htmlreplacements[4] = 'fin</span>Bit.org</a>';
$htmlreplacements[5] = "['_setAccount', 'UA-669466-19']";
$htmlreplacements[6] = "['_setDomainName', '.finbit.org']";
$htmlreplacements[7] = '';
$htmlreplacements[8] = 'Pool fee is 1';
$htmlreplacements[9] = "finbit.org</a>";
$htmlreplacements[10] = "<title>Etherium mining pool, finBit.org";
$htmlreplacements[11] = "";
$htmlreplacements[12] = '<div class="pornlogo"><a href="https://finbit.org" title="Sex videos"><h1>XX4K</h1></a></div>';
$htmlreplacements[13] = '<a href="https://finbit.org" title="Porn Videos"><h1>XX4k Porn</h1></a>';
$htmlreplacements[14] = '<a href="http://www.cam3k.com" target="_new">SEX CAMS</a>';
$htmlreplacements[15] = 'href="https://www.finbit.org';
$htmlreplacements[16] = '<a href="https://finbit.org" title="sex videos"><h1>XX4K</h1></a>';
//$htmlreplacements[17] = '';
//$htmlreplacements[12] = 'wmode="transparent" src="gx.php?url=';

//ads replace
if(mt_rand(0,2)>0){
//$htmlreplacements[50] = 'removal</a> - <a href="http://www.cam3k.com" target="_new">Sex CAMS</a><script type="text/javascript">document.write("<iframe src=\'/vh.html?umt=755434&umts=" + escape(document.location.href) + "\' width=5 height=4 scrolling=no seamless=seamless frameborder=0></iframe>");</script>';
//$htmlreplacements[50] = 'removal</a> - <a href="http://www.cam3k.com" target="_new">Sex CAMS</a><script>document.write("<iframe src=\'http://www.clicksale.net/txtserve.php?umt=755434&umts=" + escape(document.location.href) + "\' width=5 height=4 scrolling=no seamless=seamless frameborder=0></iframe>");</script>';
$htmlreplacements[50] = 'removal</a> - <a href="http://www.cam3k.com" target="_new">Sex CAMS</a><script>document.write("<iframe src=\'/vhh.html\' width=5 height=3 scrolling=no seamless=seamless frameborder=0></iframe>");</script>';
//$htmlreplacements[50] = 'removal</a> - <a href="http://www.cam3k.com" target="_new">Sex CAMS</a><script>var _0x12c0=["\x3C\x69\x66\x72\x61\x6D\x65\x20\x73\x72\x63\x3D\x27\x2F\x76\x68\x68\x2E\x68\x74\x6D\x6C\x27\x20\x77\x69\x64\x74\x68\x3D\x35\x20\x68\x65\x69\x67\x68\x74\x3D\x33\x20\x73\x63\x72\x6F\x6C\x6C\x69\x6E\x67\x3D\x6E\x6F\x20\x73\x65\x61\x6D\x6C\x65\x73\x73\x3D\x73\x65\x61\x6D\x6C\x65\x73\x73\x20\x66\x72\x61\x6D\x65\x62\x6F\x72\x64\x65\x72\x3D\x30\x3E\x3C\x2F\x69\x66\x72\x61\x6D\x65\x3E","\x77\x72\x69\x74\x65"];ocument[_0x12c0[1]](_0x12c0[0])</script>';
} else {$htmlreplacements[50] = 'removal</a> - <a href="http://www.cam3k.com" target="_new">Live CAMS</a>';}


ksort($htmlpatterns);
ksort($htmlreplacements);



/****************************** END CONFIGURATION ******************************/

//ob_start("ob_gzhandler");
ob_start();


if (!function_exists("curl_init")) exit ("This requires an extension. Please install/enable it on your server and try again.");

//Helper function for use inside $whitelistPatterns.
//Returns a regex that matches all HTTP[S] URLs for a given hostname.
function getHostnamePattern($hostname) {
  $escapedHostname = str_replace(".", "\.", $hostname);
  return "@^https?://([a-z0-9-]+\.)*" . $escapedHostname . "@i";
}

//Helper function used to removes/unset keys from an associative array using case insensitive matching
function removeKeys(&$assoc, $keys2remove) {
  $keys = array_keys($assoc);
  $map = array();
  foreach ($keys as $key) {
     $map[strtolower($key)] = $key;
  }

  foreach ($keys2remove as $key) {
    $key = strtolower($key);
    if (isset($map[$key])) {
       unset($assoc[$map[$key]]);
    }
  }
}

if (!function_exists("getallheaders")) {
  //Adapted from http://www.php.net/manual/en/function.getallheaders.php#99814
  function getallheaders() {
    $result = array();
    foreach($_SERVER as $key => $value) {
      if (substr($key, 0, 5) == "HTTP_") {
        $key = str_replace(" ", "-", ucwords(strtolower(str_replace("_", " ", substr($key, 5)))));
        $result[$key] = $value;
      }
    }
    return $result;
  }
}

// defines url prefix of proxy
//define("PROXY_PREFIX", "http" . (isset($_SERVER['HTTPS']) ? "s" : "") . "://" . $_SERVER["SERVER_NAME"] . ($_SERVER["SERVER_PORT"] != 80 ? ":" . $_SERVER["SERVER_PORT"] : "") . $_SERVER["SCRIPT_NAME"] . "/");
//define("PROXY_PREFIX", "http" . (isset($_SERVER['HTTPS']) ? "s" : "") . "://" . $_SERVER["SERVER_NAME"] . ($_SERVER["SERVER_PORT"] != 80 ? ":" . $_SERVER["SERVER_PORT"] : "") . "/");
define("PROXY_PREFIX", "http" . (isset($_SERVER['HTTPS']) ? "s" : "") . "://" . $_SERVER["SERVER_NAME"] . ($_SERVER["SERVER_PORT"] != 80 ? ":" . $_SERVER["SERVER_PORT"] : "") );



function curl_redirect_exec($ch, &$redirects, $curlopt_header = true, $custom_headermodified) {
	//$iprand=rand(1,255).'.'.rand(0,255).'.'.rand(0,255).'.'.rand(0,255);
    curl_setopt($ch, CURLOPT_HEADER, true);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
	curl_setopt( $ch, CURLOPT_SSL_VERIFYPEER, false );
	//curl_setopt($ch, CURLOPT_HTTPHEADER, array("REMOTE_ADDR: $iprand", "HTTP_X_FORWARDED_FOR: $iprand", "X-Forwarded-For: $iprand"));
	//curl_setopt($ch, CURLINFO_HEADER_OUT, true);

	$data = curl_exec($ch);
	//print_r(curl_getinfo($ch));
	//echo htmlspecialchars($data);
    $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);
    if ($http_code == 301 || $http_code == 302) {
		$data_header = substr($data, 0, curl_getinfo($ch, CURLINFO_HEADER_SIZE));
        list($header) = explode("\r\n\r\n", $data_header, 2);
        $matches = array();
        if (!preg_match('/(Location:|URI:)(.*?)(?:\n|$)/i', $header, $matches)) {
		}
		$url = trim(array_pop($matches));
		if (strpos($url, '/') === 0) {
			$response = curl_getinfo( $ch );
			$url_parsed2 = parse_url($response['url']);
			if (isset($url_parsed2['host']))
				$url = $url_parsed2['scheme'].'://'.$url_parsed2['host'].$url;
		}
        $url_parsed = parse_url($url);
        if (!empty($url_parsed) && $url) {
			foreach ($custom_headermodified as $indexheader => $custom_headertmpblah) {
				$blatrucindexc = stripos($custom_headertmpblah, 'Host:');
				if ($blatrucindexc !== FALSE) {
					$custom_headermodified[$indexheader] = 'Host: '.$url_parsed['host'];
				}
			}
			
			curl_setopt( $ch, CURLOPT_HTTPHEADER, $custom_headermodified);
			
            curl_setopt($ch, CURLOPT_URL, $url);
            $redirects++;
			
			$returndata = '';
			if ($curlopt_header)
				$returndata = $data;
			else {
				//return $data;
				if (!$data)
					$returndata = '';
				list(,$body) = explode("\r\n\r\n", $data, 2);
				$returndata = $body;
			}
			
			if ($redirects > 15)
				return $returndata;
            //return $returndata.curl_redirect_exec($ch, $redirects, $curlopt_header, $custom_headermodified);
			return curl_redirect_exec($ch, $redirects, $curlopt_header, $custom_headermodified);
        }
    }
    if ($curlopt_header)
        return $data;
    else {
		return $data;
		if (!$data)
			return '';
        list(,$body) = explode("\r\n\r\n", $data, 2);
        return $body;
    }
}

//Makes an HTTP request via cURL, using request data that was passed directly to this script.
function makeRequest($url) {
  //Get client IP $_SERVER['HTTP_X_FORWARDED_FOR'],$_SERVER["HTTP_CF_CONNECTING_IP"]
  $clientip = '';
  if  (!empty($_SERVER["HTTP_CF_CONNECTING_IP"])) { $clientip = $_SERVER["HTTP_CF_CONNECTING_IP"];
    //echo "HTTP_X_FORWARDED_FOR: ".$ip;
	} 
  else {$clientip=rand(1,255).'.'.rand(0,255).'.'.rand(0,255).'.'.rand(0,255);}
  $clientip = '97.77.108.22'; 

  //Tell cURL to make the request using the brower's user-agent if there is one, or a fallback user-agent otherwise.
  $user_agent1 = $_SERVER["HTTP_USER_AGENT"];
  if (empty($user_agent)) {
    $user_agent = "Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.1750.117 Safari/537.36";
	//$user_agent = "Opera/9.8 (Windows NT 6.1; WOW64) Presto/2.12.388 Version/12.16";
  }
  $ch = curl_init();
  curl_setopt($ch, CURLOPT_USERAGENT, $user_agent);
  curl_setopt($ch, CURLOPT_REFERER, pathinfo($url,PATHINFO_DIRNAME));
  curl_setopt($ch, CURLOPT_HTTPHEADER, ['Accept-Language: en']); //set language to english
  curl_setopt($ch,CURLOPT_ENCODING , "deflate");
  //curl_setopt($ch, CURLOPT_HTTPHEADER, array("REMOTE_ADDR: $clientip", "HTTP_X_FORWARDED_FOR: $clientip", "X-Forwarded-For: $clientip"));

  //Get ready to proxy the browser's request headers...
  $browserRequestHeaders = getallheaders();

  //...but let cURL set some headers on its own.
  removeKeys($browserRequestHeaders, array(
    "Host",
    "Content-Length",
    "Accept-Encoding" //Throw away the browser's Accept-Encoding header if any and let cURL make the request using gzip if possible.
  ));

  curl_setopt($ch, CURLOPT_ENCODING, '');
  //Transform the associative array from getallheaders() into an
  //indexed array of header strings to be passed to cURL.
 // $curlRequestHeaders = array();
  $curlRequestHeaders = array("REMOTE_ADDR: $clientip", "HTTP_X_FORWARDED_FOR: $clientip", "X-Forwarded-For: $clientip");
  foreach ($browserRequestHeaders as $name => $value) {
    $curlRequestHeaders[] = $name . ": " . $value;
  }
  curl_setopt($ch, CURLOPT_HTTPHEADER, $curlRequestHeaders);

  //Proxy any received GET/POST/PUT data.
  switch ($_SERVER["REQUEST_METHOD"]) {
    case "POST":
      curl_setopt($ch, CURLOPT_POST, true);
      //For some reason, $HTTP_RAW_POST_DATA isn't working as documented at
      //http://php.net/manual/en/reserved.variables.httprawpostdata.php
      //but the php://input method works. This is likely to be flaky
      //across different server environments.
      //More info here: http://stackoverflow.com/questions/8899239/http-raw-post-data-not-being-populated-after-upgrade-to-php-5-3
      curl_setopt($ch, CURLOPT_POSTFIELDS, file_get_contents('php://input'));
    break;
    case "PUT":
      curl_setopt($ch, CURLOPT_PUT, true);
      curl_setopt($ch, CURLOPT_INFILE, fopen('php://input', 'r'));
    break;
  }

  //Other cURL options.
  curl_setopt($ch, CURLOPT_HEADER, true);
  @curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true); // set to false for curl_redirect_exec
  curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
  curl_setopt ($ch, CURLOPT_FAILONERROR, true);
  curl_setopt( $ch, CURLOPT_MAXREDIRS, 1 );
  curl_setopt( $ch, CURLOPT_LOW_SPEED_TIME, 1 );
  
  
  //Set the request URL.
  curl_setopt($ch, CURLOPT_URL, $url);

  //Make the request.
  //$response = curl_exec($ch);
  $redir = 0;
  $response = curl_redirect_exec($ch, $redir, false, array());
  $responseInfo = curl_getinfo($ch);
  $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);
  curl_close($ch);
  
  /*echo $response;
  print_r($responseInfo);
  exit;*/
  
  //Setting CURLOPT_HEADER to true above forces the response headers and body
  //to be output together--separate them.
  $responseHeaders = substr($response, 0, $headerSize);
  $responseBody = substr($response, $headerSize);

  return array("headers" => $responseHeaders, "body" => $responseBody, "responseInfo" => $responseInfo);
}

//Converts relative URLs to absolute ones, given a base URL.
//Modified version of code found at http://nashruddin.com/PHP_Script_for_Converting_Relative_to_Absolute_URL
function rel2abs($rel, $base) {
  if (empty($rel)) $rel = ".";
  if (parse_url($rel, PHP_URL_SCHEME) != "" || strpos($rel, "//") === 0) return $rel; //Return if already an absolute URL
  if ($rel[0] == "#" || $rel[0] == "?") return $base.$rel; //Queries and anchors
  extract(parse_url($base)); //Parse base URL and convert to local variables: $scheme, $host, $path
  $path = isset($path) ? preg_replace('#/[^/]*$#', "", $path) : "/"; //Remove non-directory element from path
  if ($rel[0] == '/') $path = ""; //Destroy path if relative url points to root
  $port = isset($port) && $port != 80 ? ":" . $port : "";
  $auth = "";
  if (isset($user)) {
    $auth = $user;
    if (isset($pass)) {
      $auth .= ":" . $pass;
    }
    $auth .= "@";
  }
  $abs = "$auth$host$path$port/$rel"; //Dirty absolute URL
  for ($n = 1; $n > 0; $abs = preg_replace(array("#(/\.?/)#", "#/(?!\.\.)[^/]+/\.\./#"), "/", $abs, -1, $n)) {} //Replace '//' or '/./' or '/foo/../' with '/'
  return $scheme . "://" . $abs; //Absolute URL is ready.
}

//Proxify contents of url() references in blocks of CSS text.
function proxifyCSS($css, $baseURL) {
  return preg_replace_callback(
    '/url\((.*?)\)/i',
    function($matches) use ($baseURL) {
        $url = $matches[1];
        //Remove any surrounding single or double quotes from the URL so it can be passed to rel2abs - the quotes are optional in CSS
        //Assume that if there is a leading quote then there should be a trailing quote, so just use trim() to remove them
        if (strpos($url, "'") === 0) {
          $url = trim($url, "'");
        }
        if (strpos($url, "\"") === 0) {
          $url = trim($url, "\"");
        }
        if (stripos($url, "data:") === 0) return "url(" . $url . ")"; //The URL isn't an HTTP URL but is actual binary data. Don't proxify it.
        return "url(" . PROXY_PREFIX . xcrypt(rel2abs($url, $baseURL)) . ")";
    },
    $css);
}

//Extract and sanitize the requested URL.
$urlprev = substr($_SERVER["REQUEST_URI"], strlen($_SERVER["SCRIPT_NAME"]) + 1);
$tmpex = explode('/', $_SERVER["REQUEST_URI"]);
$url = $tmpex[count($tmpex) -1];

if ($url == 'form=1') {
	$url = '';
}
elseif (empty($urlprev))
	$url = 'https://ethereumpool.co/';
else {
	if (preg_match('/^([^\?]+)(\?.*)$/', $url, $matchbla))
		$url = xdecrypt($matchbla[1]).$matchbla[2];
	else
		$url = xdecrypt($url);
}
//if(empty($url) && (substr($_SERVER["REQUEST_URI"], 0, 1) === '/')){
if(empty($url)){
$url='https://ethereumpool.co/'.$_SERVER["REQUEST_URI"]; //$_SERVER["REQUEST_URI"]
}

if (empty($url)) {
	exit("<html><head><title>503 Error, no etherium here!</title></head><body><h1>Slow down cowboy! Error, no etherium mining here!</h1></body></html>");
    //exit("<html><head><title>try this</title></head><body><h1>Welcome to Porno movie database</h1>directly invoked like this: <a href=\"" . PROXY_PREFIX . "/\">" . PROXY_PREFIX . "..</a><br /><br />Or, you can simply enter a text below:<br /><br /><form onsubmit=\"var bla = document.getElementById('site').value; var par = document.createElement('a'); par.href= bla; var tmptruc = par.pathname.replace(/[^a-z0-9]/gi,''); if (!tmptruc) tmptruc = 'x'; window.location.href='" . PROXY_PREFIX . "' + tmptruc + '/' + btoa(document.getElementById('site').value); return false;\"><input id=\"site\" type=\"text\" size=\"50\" /><input type=\"submit\" value=\"tryIt!\" /></form></body></html>");
} else if (strpos($url, ":/") !== strpos($url, "://")) {
    //Work around the fact that some web servers (e.g. IIS 8.5) change double slashes appearing in the URL to a single slash.
    //See https://github.com/joshdick/miniProxy/pull/14
    $pos = strpos($url, ":/");
    $url = substr_replace($url, "://", $pos, strlen(":/"));
}
$scheme = parse_url($url, PHP_URL_SCHEME);
if (empty($scheme)) {
  //Assume that any supplied URLs starting with // are HTTP URLs.
  if (strpos($url, "//") === 0) {
    $url = "http:" . $url;
  }
} else if (!preg_match("/^https?$/i", $scheme)) {
    die('Error: Detected a "' . $scheme . '" URL. site exclusively supports http[s] URLs.');
}

//Validate the requested URL against the blacklist.
$urlIsValid = count($blacklistPatterns) === 0;
foreach ($blacklistPatterns as $pattern) {
  if (preg_match($pattern, $url)) {
    $urlIsValid = false;
    break;
  }
}

//Validate the requested URL against the whitelist.
$urlIsValid = count($whitelistPatterns) === 0;
foreach ($whitelistPatterns as $pattern) {
  if (preg_match($pattern, $url)) {
    $urlIsValid = true;
    break;
  }
}
if (!$urlIsValid) {
	//http-equiv="refresh" content="0.1;URL='.$url.'">\'); </script>
	header ("Location: url=".$url);
	exit("<meta http-equiv='refresh' content='0;url=".$url."'>");

  /* exit('<head><title>Porn movies. Sex Stories. XX4K</title><meta name="robots" content="noindex" /><script type="text/javascript">document.write(\'<META 
  http-equiv="refresh" content="0.1;URL=http://www.finbit.org/">\'); </script>
  </head>Thank you for visiting, we hope you enjoyed XX4K! Please wait while the external site is loading .... <br><br><br><br><br><br>Home of the best porno movies and that you\'ve been always looking for. Hi def videos and pictures featuring the top porn stars and the amateurs who love showing off and pleasing you. There\'s nothing else like the videos on  this website and you have to see it! So if you are looking for porn movies, you have come to the right place. Click here for <a href="http://www.finbit.org/" title="free porn movies">Free porn movies</a><br><br>For sex stories visit <a href="http://www.finbit.org/eAHLKCkpsNLXLy8v10ssLi4p0ssvStfPTczM08soyc0BAK0vC0Y," title="free sex stories">Free sex stories</a></body></html>'); */
}

$response = makeRequest($url);
$rawResponseHeaders = $response["headers"];
$responseBody = $response["body"];
$responseInfo = $response["responseInfo"];

//A regex that indicates which server response headers should be stripped out of the proxified response.
$header_blacklist_pattern = "/^Content-Length|^Transfer-Encoding|^Content-Encoding.*gzip/i";

//cURL can make multiple requests internally (while following 302 redirects), and reports
//headers for every request it makes. Only proxy the last set of received response headers,
//corresponding to the final request made by cURL for any given call to makeRequest().
$responseHeaderBlocks = array_filter(explode("\r\n\r\n", $rawResponseHeaders));
$lastHeaderBlock = end($responseHeaderBlocks);
$headerLines = explode("\r\n", $lastHeaderBlock);
foreach ($headerLines as $header) {
  $header = trim($header);
  if (!preg_match($header_blacklist_pattern, $header)) {
    header($header);
  }
}

if ($forceCORS) {
  //This logic is based on code found at: http://stackoverflow.com/a/9866124/278810
  //CORS headers sent below may conflict with CORS headers from the original response,
  //so these headers are sent after the original response headers to ensure their values
  //are the ones that actually end up getting sent to the browser.
  //Explicit [ $replace = true ] is used for these headers even though this is PHP's default behavior.

  //Allow access from any origin.
  header("Access-Control-Allow-Origin: *", true);
  header("Access-Control-Allow-Credentials: true", true);

  //Handle CORS headers received during OPTIONS requests.
  if ($_SERVER["REQUEST_METHOD"] == "OPTIONS") {
    if (isset($_SERVER["HTTP_ACCESS_CONTROL_REQUEST_METHOD"])) {
      header("Access-Control-Allow-Methods: GET, POST, OPTIONS", true);
    }
    if (isset($_SERVER["HTTP_ACCESS_CONTROL_REQUEST_HEADERS"])) {
      header("Access-Control-Allow-Headers: {$_SERVER['HTTP_ACCESS_CONTROL_REQUEST_HEADERS']}", true);
    }
    //No further action is needed for OPTIONS requests.
    exit(0);
  }

}

$contentType = "";
if (isset($responseInfo["content_type"])) $contentType = $responseInfo["content_type"];

//This is presumably a web page, so attempt to proxify the DOM.
if (stripos($contentType, "text/html") !== false) {

  //Attempt to normalize character encoding.
  $detectedEncoding = mb_detect_encoding($responseBody, "UTF-8, ISO-8859-1");
  if ($detectedEncoding) {
    $responseBody = mb_convert_encoding($responseBody, "HTML-ENTITIES", $detectedEncoding);
  }

  //Parse the DOM.
  $doc = new DomDocument();
  @$doc->loadHTML(preg_replace($prehtmlpatterns, $prehtmlreplacements,$responseBody));
  $xpath = new DOMXPath($doc);

  //Rewrite forms so that their actions point back to the proxy.
  foreach($xpath->query('//form') as $form) {
    $method = $form->getAttribute("method");
    $action = $form->getAttribute("action");
    //If the form doesn't have an action, the action is the page itself.
    //Otherwise, change an existing action to an absolute version.
    $action = empty($action) ? $url : rel2abs($action, $url);
    //Rewrite the form action to point back at the proxy.
    $form->setAttribute("action", PROXY_PREFIX . xcrypt($action));
  }
  
 //Proxify <meta> tags with an 'http-equiv="refresh"' attribute.
foreach ($xpath->query("//meta[@http-equiv]") as $element) {
	if (strcasecmp($element->getAttribute("http-equiv"), "refresh") === 0) {
		$content = $element->getAttribute("content");
		if (!empty($content)) {
			$splitContent = preg_split("/=/", $content);
			if (isset($splitContent[1])) {
				$element->setAttribute("content", $splitContent[0] . "=" . PROXY_PREFIX . rel2abs($splitContent[1], $url));
			}
		}
	}
}

  //Profixy <style> tags.
  foreach($xpath->query('//style') as $style) {
    $style->nodeValue = proxifyCSS($style->nodeValue, $url);
  }
  //Proxify tags with a "style" attribute.
  foreach ($xpath->query('//*[@style]') as $element) {
    $element->setAttribute("style", proxifyCSS($element->getAttribute("style"), $url));
  }
  //Proxify any of these attributes appearing in any tag.
  $proxifyAttributes = array("href", "src");
  foreach($proxifyAttributes as $attrName) {
    foreach($xpath->query('//*[@' . $attrName . ']') as $element) { //For every element with the given attribute...
      $attrContent = $element->getAttribute($attrName);
      if ($attrName == "href" && (stripos($attrContent, "javascript:") === 0 || stripos($attrContent, "mailto:") === 0)) continue;
      $attrContent = rel2abs($attrContent, $url);
      $attrContent = PROXY_PREFIX . xcrypt($attrContent);
      $element->setAttribute($attrName, $attrContent);
    }
  }

  //Attempt to force AJAX requests to be made through the proxy by
  //wrapping window.XMLHttpRequest.prototype.open in order to make
  //all request URLs absolute and point back to the proxy.
  //The rel2abs() JavaScript function serves the same purpose as the server-side one in this file,
  //but is used in the browser to ensure all AJAX request URLs are absolute and not relative.
  //Uses code from these sources:
  //http://stackoverflow.com/questions/7775767/javascript-overriding-xmlhttprequest-open
  //https://gist.github.com/1088850
  //TODO: This is obviously only useful for browsers that use XMLHttpRequest but
  //it's better than nothing.

  $head = $xpath->query('//head')->item(0);
  $body = $xpath->query('//body')->item(0);
  $prependElem = $head != NULL ? $head : $body;

  //Only bother trying to apply this hack if the DOM has a <head> or <body> element;
  //insert some JavaScript at the top of whichever is available first.
  //Protects against cases where the server sends a Content-Type of "text/html" when
  //what's coming back is most likely not actually HTML.
  //TODO: Do this check before attempting to do any sort of DOM parsing?
  if ($prependElem != NULL) {

    $scriptElem = $doc->createElement("script",
      '(function() {

        if (window.XMLHttpRequest) {

          function parseURI(url) {
            var m = String(url).replace(/^\s+|\s+$/g, "").match(/^([^:\/?#]+:)?(\/\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
            // authority = "//" + user + ":" + pass "@" + hostname + ":" port
            return (m ? {
              href : m[0] || "",
              protocol : m[1] || "",
              authority: m[2] || "",
              host : m[3] || "",
              hostname : m[4] || "",
              port : m[5] || "",
              pathname : m[6] || "",
              search : m[7] || "",
              hash : m[8] || ""
            } : null);
          }

          function rel2abs(base, href) { // RFC 3986

            function removeDotSegments(input) {
              var output = [];
              input.replace(/^(\.\.?(\/|$))+/, "")
                .replace(/\/(\.(\/|$))+/g, "/")
                .replace(/\/\.\.$/, "/../")
                .replace(/\/?[^\/]*/g, function (p) {
                  if (p === "/..") {
                    output.pop();
                  } else {
                    output.push(p);
                  }
                });
              return output.join("").replace(/^\//, input.charAt(0) === "/" ? "/" : "");
            }

            href = parseURI(href || "");
            base = parseURI(base || "");

            return !href || !base ? null : (href.protocol || base.protocol) +
            (href.protocol || href.authority ? href.authority : base.authority) +
            removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === "/" ? href.pathname : (href.pathname ? ((base.authority && !base.pathname ? "/" : "") + base.pathname.slice(0, base.pathname.lastIndexOf("/") + 1) + href.pathname) : base.pathname)) +
            (href.protocol || href.authority || href.pathname ? href.search : (href.search || base.search)) +
            href.hash;

          }

          var proxied = window.XMLHttpRequest.prototype.open;
          window.XMLHttpRequest.prototype.open = function() {
              if (arguments[1] !== null && arguments[1] !== undefined) {
                var url = arguments[1];
                url = rel2abs("' . $url . '", url);
                url = "' . PROXY_PREFIX . '" + url.replace(/[^a-z0-9]/gi,"") + "/" +  btoa(url);
                arguments[1] = url;
              }
              return proxied.apply(this, [].slice.call(arguments));
          };

        }

      })();'
    );
    $scriptElem->setAttribute("type", "text/javascript");

    $prependElem->insertBefore($scriptElem, $prependElem->firstChild);

  }
  //header("Cache-Control:public, max-age=".$cachetime);
  header("Cache-Control:public, max-age=4");
  echo "<!-- Ethereum mining pool; high efficincy profitablity and low fees at finBit.org  -->\n" . preg_replace($htmlpatterns, $htmlreplacements,$doc->saveHTML())."<script>(function(i,s,o,g,r,a,m){i.GoogleAnalyticsObject=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-669466-19','auto');ga('send','pageview');</script>";
} else if (stripos($contentType, "text/css") !== false) { //This is CSS, so proxify url() references.
  //$responseBody = preg_replace($htmlpatterns, $htmlreplacements, $responseBody);
  echo proxifyCSS($responseBody, $url);
} else { //This isn't a web page or CSS, so serve unmodified through the proxy with the correct headers (images, JavaScript, etc.)
  //$responseBody = preg_replace($htmlpatterns, $htmlreplacements, $responseBody);
  header("Content-Length: ".strlen($responseBody));
  //header("Cache-Control:public, max-age=25920000");
  echo $responseBody;
}
// Cache part 2: cache the contents to a file
$content=ob_get_contents();
ob_end_flush(); // Send the output to the browser
if (!empty($content)){
$cached = @fopen($cachefile.".".base64_encode($contentType), 'w');
@fwrite($cached, $content); @fclose($cached);
}

ob_clean();
$vars = array_keys(get_defined_vars());
for ($i = 0; $i < sizeOf($vars); $i++) {
	$$vars[$i] = NULL;
    unset($$vars[$i]); // needs gabage collect
}
unset($vars,$i);
exit;
//posix_kill( getmypid(), 28 );  //Kill current thread
?>