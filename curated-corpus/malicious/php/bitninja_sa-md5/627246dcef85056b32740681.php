<?php
include_once( dirname(__FILE__)."/backend/config.php" ); 
header("Access-Control-Allow-Origin: *");

set_time_limit(0);

# SERVER IP AND PORT WHICH NEED TO BIND FOR SOCKET CONNECTION
define('HOST_NAME',"173.209.62.226"); 
define('PORT',"8091");
define('PATH', dirname( __FILE__ ) );

# STREAM SOCKET CREATION OVER SSL(WSS)
$context = stream_context_create(); 

$sock = stream_socket_server("tcp://".HOST_NAME.":".PORT, $errno, $errstr, STREAM_SERVER_BIND|STREAM_SERVER_LISTEN, $context) or die("Unable to start server, $errstr!"); 

# PUTTING ALL(CURRENT/UPCOMING) SOCKET CONNECTIONS IN ARRAY
$clients = array();


# TRAYS TO MANAGE EACH SOCKET CONNECTION 
$incomplete_data = array();
$clients_lobbies = array();
$received_header = array();
$handshakes = array();
$clientData = array();      # HOLDS EACH CLIENT WITH ITS REMOTE ADDRESS
$tray_clients = array();    # HOLDS EACH CLIENT DATA WHICH NEEDS TO SEND HIM BY SERVER
$this_new_client_id = 0;    # IDS 

$clients_connections_IDs = array(); # will contain client connection and user ID array

$notifyOnlineUser = array('
    _user' => '',  # Whom to notify
    'id' => '',    # ID of user about whom this notification is
    'name' => '',  # Full name of user about whom this notification is
    'type' => '',  # user type of user about whom this notification is - possible values admin/visitor
    'status' => '' # notification type
    );
# END OF MARK, USED IN HEADER TO SEPARATE DATA FROM HEADERS

$end_of_data = "EOD_MARK";

$first_sock_id = zptGenerateSockId($tray_clients);
$clients[$first_sock_id] = $sock; # HOLD VERY FIRST CLIENT
$tray_clients[$first_sock_id] = array();

# INFINTE LOOP THOURGH ALL SOCKECT CURRENT/UPCOMING CONNECTIONS, SEND/RECEIVE DATA


file_put_contents(dirname(__FILE__)."/connect.json", json_encode(array("connect" => true)));

$wc_connect = true;
$abc = 0;
while ($wc_connect) {
    
    # ALL ACTIVE SOCKET CONNECTIONS
    $read = $clients;
    
    foreach($received_header as $key => $header){
        if($header['time']+1 < microtime(true)){
            $headers  = [];
            // echo $header['data'];
            $lines    = preg_split("/\r\n/", $header['data']);
            foreach($lines as $line) {
                $line = chop($line);
                if(preg_match('/\A(\S+): (.*)\z/', $line, $matches)){
                    $headers[$matches[1]] = $matches[2];
                }
            }
            $secKey     = $headers['Sec-WebSocket-Key'];
            $secAccept  = base64_encode(pack('H*', sha1($secKey . '258EAFA5-E914-47DA-95CA-C5AB0DC85B11')));

            // create handshake header
            $upgrade  = "HTTP/1.1 101 Web Socket Protocol Handshake\r\n" .
            "Upgrade: websocket\r\n" .
            "Connection: Upgrade\r\n" .
            "Accept: text/html\r\n" .
            "Sec-WebSocket-Accept: $secAccept\r\n\r\n";

            // send handshake packet
            if(!fwrite($clients[$key], $upgrade)){
                // file_put_contents('handshakes.txt', 'Hand Shake: '.json_encode($handshakes).PHP_EOL, FILE_APPEND);
            }else{
                // file_put_contents('handshakes.txt', 'Hand Shake: '.json_encode($clients).PHP_EOL, FILE_APPEND);
            }
            $handshakes[$key] = true;
            $unset_key = $key;
        }
    }
    
    if(isset($unset_key)){
        unset($received_header[$key]);
        unset($unset_key);
    }

    # check incomplete data and delete the data after 5 seconds
    $unset_keys = array();
    foreach($incomplete_data as $key => $array){
        if($array['last_update']+5 < microtime(true)){
            $unset_keys[$key] = true;
        }
    }
    
    foreach($unset_keys as $key => $arr){
        unset($incomplete_data[$key]);
    }
    
    unset($unset_keys);
    
    $write = NULL;
    $except = NULL;
    
    # get a list of all the clients that have data to be read from
    # if there are no clients with data, go to next iteration
    if (FALSE !== @stream_select($read, $write, $except, 0)){
    
        
        # check if there is a client trying to connect
        if (in_array($sock, $read)) {
            # accept the client, and add him to the $clients array
            
            $this_new_client_id = zptGenerateSockId( $tray_clients ) ; # GENERATE NEW ID FOR CURRENT CLIENT
            
            $tmp_client = stream_socket_accept($sock);
            $tray_clients[$this_new_client_id] = array();
            $clients[$this_new_client_id] = $tmp_client;
            
            /*
            $stream_name = stream_socket_get_name($tmp_client, true);
            if($stream_name !== false){
                $userIp = explode(":",$stream_name)[0];
                $tray_clients[$this_new_client_id]['userIp'] = $userIp;
            }
            */
            
            # remove the listening socket from the clients-with-data array
            $key = array_search($sock, $read);
            unset($read[$key]);
        }
        
        # loop through all the clients that have data to read from
        foreach ($read as $read_sock) {
            
            # EACH CONNECTION(CLIENT) DATA TRAY TO RESPOND
            $zpt_connection_respond_tray = chat_sample_response_tray();
            
            # get and process user connection ip 
            $stream_name = stream_socket_get_name($read_sock, true);
            if($stream_name !== false){
                
                $user_ip = trim(explode(":", $stream_name)[0]);
                $zpt_connection_respond_tray['ip'] = $user_ip; # keep the user connection ip in tray
            }
            
            
            
            // read until newline or 1024 bytes
            $key = array_search($read_sock, $clients);
            
            $data = fread($read_sock, 8192); 
            
            //get the headers for the first handshake
            if(!isset($handshakes[$key])){
                //we need to handshake it first before we continue with normal operation
                if(isset($received_header[$key]['data'])){
                    $received_header[$key]['data'] .= $data;
                }else{
                    $received_header[$key]['data'] = $data;
                }
                $received_header[$key]['time'] = microtime(true);
                continue;
            }
            
            # check if the client is disconnected
            if ($data === "" || $data === FALSE) {
                
                # remove client from $clients array
                $key = array_search($read_sock, $clients);
                file_put_contents( dirname(__FILE__).'/disconnected.txt', $key.PHP_EOL, FILE_APPEND);
                
                fclose($read_sock);
                unset($clients[$key]);
                unset($tray_clients[$key]);
                
                # remove client from lobbies
                if(isset($clients_lobbies[$key])){
                    foreach($clients_lobbies[$key] as $lobbyid => $boolean){
                        unset($lobbies[$lobbyid]['clients'][$key]);
                    }
                }
                
                unset($received_header[$key]);
                unset($handshakes[$key]);
                
                # remove clients indexed lobbies
                unset($clients_lobbies[$key]);
                unset($incomplete_data[$key]);
                
                unset($clients_connections_IDs[$key]);
                
                
                # continue to the next client to read from, if any
                continue;
            }
            
            
    
            # check if there is any data after trimming off the spaces
            if (!empty($data)) {
                
                
                $parsing_data = array();
                
                
                # PARSE DATA HERE, Direct the messages into the lobbies according to headers, headers will tell if the user wants to join another lobby, what lobby the message is from etc,
                if($key !== false && isset($handshakes[$key])){
                    
                    if(isset($incomplete_data[$key])){
                        echo "__incomplete data__";
                        $data = $incomplete_data[$key]['data'].$data;
                        $incomplete_data[$key]['data'] = $data;
                        $incomplete_data[$key]['last_update'] = microtime(true);
                    }
                    else{
                        $incomplete_data[$key]['data'] = $data;
                        $incomplete_data[$key]['last_update'] = microtime(true);
                    }
                    
                    if(false && substr_compare($data, $end_of_data,-strlen($end_of_data) !== 0)){//check if data has arrived completely
                        $incomplete_data[$key]['data'] = $data;
                        $incomplete_data[$key]['last_update'] = microtime(true);
                        continue;
                    }
                    else{
                        $_POSTED = json_decode(trim(unmask($data)), true);
                        
                        /* READ EACH CLIENT REQUEST 1 BY 1
                         * 
                         * @request-manager.php contains script which handles all requests which server support
                         *
                         */
                        include (dirname(__FILE__)."/backend/request-manager.php");
                    }
                }
            }
            
        } # end of reading foreach
        
    } # end of if, if there is client that have data to b read from
    
    
    # here it comes the additional functionality where you can loop through all the active user connections and can process data
    
    
    
    // loop through all the clients that are connected
    foreach ($clients as $client_id => $v) {
        
        file_put_contents( dirname(__FILE__)."/typing.txt", json_encode($tray_clients));
        
        # this used to stop the server incase of any error or need to restrat
        $get_c = json_decode(file_get_contents(dirname(__FILE__)."/_logs_/connections.json"), true);
        if($get_c && !empty($get_c) && $get_c["track"] == "true"){
            
            $uID = $tray_clients[$client_id]['cached']['user_id'];
            
            file_put_contents( dirname(__FILE__).'/clients.txt', $client_id." ".$uID.PHP_EOL, FILE_APPEND);
        }
        
        # AUTO RESPOND BACK TO EACH CLIENT ON EACH ITERATION.
        if(isset($tray_clients[$client_id]['content'])){
            $zpt_client_content_tray = $tray_clients[$client_id]['content'];  # return latest data
        }
        else{
            $zpt_client_content_tray = array();
        }
        
        if(isset($tray_clients[$client_id]['cached']) && !empty($tray_clients[$client_id]['cached'])){
            $zpt_resp_tray_cache = $tray_clients[$client_id]['cached']; #retrun cached data
        }
        else{
            $zpt_resp_tray_cache = array('data' => array('you' => array('data' => array('id' => 0)), 'adminInfo' => array('id' => 0)));
        }
        
        
        if(isset($tray_clients[$client_id]['cached']['data']['profile']['id']) 
        && !empty($tray_clients[$client_id]['cached']['data']['profile']['id']) ){
            
            $userID = $tray_clients[$client_id]['cached']['data']['profile']['id'];
            
            # this wiull send the new received messages to the user
            $received_messages = chat_process_received_msg($userID);
            if($received_messages && !empty($received_messages)){
                
                # file_put_contents('receive.txt', json_encode($received_messages));
                    
                $zpt_resp_tray_cache['data']['messages']['new'] = $received_messages;
                $zpt_resp_tray_cache['data']['request'] = "received_messages";
                $zpt_resp_tray_cache['request'] = "received_messages";
                
                # file_put_contents('tray.txt', json_encode($zpt_resp_tray_cache));
                
                if(!fwrite($v, 
                    encode(
                        json_encode( $zpt_resp_tray_cache )
                    )
                )){
                    // file_put_contents('traces.txt', json_encode($zpt_resp_tray_cache));
                }
            }
            
            /*
            $delivered_mesaages = chat_delivered_messages($userID);
                // file_put_contents(dirname(__FILE__)."/del.txt", json_encode($delivered_mesaages));
            if($delivered_mesaages && !empty($delivered_mesaages)){
                
                
                $resp = array("type" => "success", "request" => "delivered_messages", "content" => $delivered_mesaages);
                // fwrite($v, encode( json_encode( $resp ) ) );
            }
            */
            
            # this will process the typing status for any user and will notify the target user
            if(isset( $tray_clients[$client_id]['cached']['data']['typing']['target_id'] ) && 
            !empty( $tray_clients[$client_id]['cached']['data']['typing']['target_id'] ) ){
                
                
                
                
                $is_typing = $tray_clients[$client_id]['cached']['data']['typing'];
                
                $target_id   = $is_typing['target_id'];
                $typing_time = $is_typing['time'];
                
                $current_time = strtotime(date("Y-m-d h:i:s A"));
                
                $typing_elapse = $current_time - $typing_time;
                
                if($typing_elapse <= 3 ){
                    
                    $target_connection_id = array_search($target_id, $clients_connections_IDs);
                    if($target_connection_id){
                        
                        $target_conn_obj = $clients[$target_connection_id];
                        if($target_conn_obj){
                            
                            
                            
                            $content = array(
                                'sender_id' => $userID, 
                                'receiver_id' => $target_id, 
                                'time' => $typing_time, 
                                'msg' => 'typing...', 
                            );
                            
                            $resp = array("type" => "success", "request" => "typing_status", "content" => $content);
                            
                            fwrite($target_conn_obj, encode( json_encode( $resp ) ) );
                        }
                    }
                }
            }
        }
        
        $tray_clients[$client_id]['content'] = array(); # UNSET EACH CLIENT MESSAGE TRAY, ONCE SENT
    }
    
    $abc++;
    
    
    # this used to stop the server incase of any error or need to restrat
    $get_connect = json_decode(file_get_contents(dirname(__FILE__)."/connect.json"), true);
    if($get_connect && !empty($get_connect)){
        
        $wc_connect = $get_connect["connect"];
    }

}

restore_error_handler();
ob_end_flush();
// close the listening socket
socket_close($sock);